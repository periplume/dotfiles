#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us
# SCRIPT AND SHELL SETTINGS
set -o errexit  # set -e
set -o nounset
set -o pipefail

###########################
# PREREQUISITES
###########################
 
# required commands
_requiredCommands=(git gitdisk dsink vipe fzf)

# recommended commands
_recommendedCommands=(git-sizer tig)

###########################
# ENVIRONMENT SETTINGS
###########################

# GLOBAL VARIABLES
# these never change in the context of a session
# these will be exported (in the case of fzf previews etc) 

# WORKING ENVIRONMENT
# _studioDirName is the umbrella or master namespace in which germ operates
_studioDirName=studiodev
# germ lives inside studio (into which it is designed to publish)
_germDirName=germ
# get the name of the script itself
self=$(basename $0)

# USER NAME
# the git username and email are used to create a short hash which identifies
# the user in the namespace.  it is set as a global variable and used in various
# places.  it can be overridden here.
#_user=e291

# BEHAVIOR

# TODO figure out a better means of knowing
# 1. is this an interactive shell session
# 2. is this part of a pipe
# 3. are we in our custom interactive shell (and does that matter?)
# set up logging and stdout stderr etc with traps
# possibly check for tty?
#[[ -t 1 ]] && echo 'STDOUT is attached to TTY'
#[[ -p /dev/stdout ]] && echo 'STDOUT is attached to a pipe'
#[[ ! -t 1 && ! -p /dev/stdout ]] && echo 'STDOUT is attached to a redirection'

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=false

# OUTPUT

# some color
red=$(tput setab 1; tput setaf 7)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)
prompt=$(tput setab 5; tput setaf 7)


# user output: types
# name		description														display
#----------------------------------------------------------------------------
# debug		verbose																cyan
# info		information only											blue text, green bg
# warn		warning (abnormal)										black text, yellow bg
# error		not allowed														white text, red bg
# fatal		error and exiting (out of trap)				black text, red bg, bold text?
# ask			ask user for input										white text, cyan bg
#	always expect fresh new line
# exception...after ask...in which case, take care of that immediately
# suppress if _SILENT=true
#
# call as
# _warn "message"
# _info "message"

# _fLOG creates logging functions based on
# the static features: (global variables)
#
# the three main determinants:
# _SILENT= true | false
# _LOG= true | false
# _DEBUG= true | false
#
# subordinate dependencies:
# _canLog= true | false
# _logFile= "path to file"
# $(tput colors)

_fLOG() {
	# collapsing function...sets up according to the static determinants
	# creates all log functions
	# _debug
	# _info
	# _warn
	# _error
	# _ask
	# log function usage as simple as:
	# _info "the message contents" 
	local _log=0
	local _console=0
	local _color=0
	[[ "$_SILENT" = "false" ]] && _console=1
	[[ "$_LOG" = "true" && "$_canLog" = "true" ]] && _log=1
	[[ $(tput colors) ]] && _color=1
	#
	# set up colors	
	_cDebug=$(tput setaf 6)
	_cInfo=$(tput setaf 2)
	_cWarn=$(tput setaf 11)
	_cError=$(tput setaf 1)
	_cAsk=$(tput setaf 0; tput setab 11)
	_cReset=$(tput sgr0)
	# create 5 log functions based on static determinants above
	# TODO use eval, assoc arrays and loops to build these functions with less
	# code...someday
	# CONSOLE AND LOG
	if [[ $_console = 1 && $_log = 1 ]]; then
		_debug() {
			[[ "$_DEBUG" = "false" ]] && return
			local _timeStamp=$(date +%s.%N)
			printf '%s %s\n' "${_cDebug}DEBUG${_cReset}" "${@}"
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cDebug}DEBUG${_cReset}" "${@}" >>${_logFile}
		}
		_info() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cInfo}INFO${_cReset}" "${@}" >>${_logFile}
			#printf '%s %s\n' "${_cInfo}INFO${_cReset}" "${@}"
			# hack: below prints info...multi-line messages are indented
			SAVEIFS=$IFS
			IFS=$'\n'
			_pList=(${1})
			IFS=$SAVEIFS
			if [[ ${#_pList[@]} -gt 1 ]]; then
				printf '%s %s\n' "${_cInfo}INFO${_cReset}" "${_pList[0]} "
				for (( i=1; i<${#_pList[@]}; i++ ))
				do
					printf "\t\t: %s\n" "${_pList[$i]} "
				done
			else
				printf "%s %s\n" "${_cInfo}INFO${_cReset}" "${1} "
			fi
		}
		_warn() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s\n' "${_cWarn}WARN${_cReset}" "${@}"
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cWarn}WARN${_cReset}" "${@}" >>${_logFile}
		}
		_error() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s\n' "${_cError}ERROR${_cReset}" "${@}"
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cError}ERROR${_cReset}" "${@}" >>${_logFile}
		}
		_ask() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s' "${_cAsk}USER${_cReset}" "${@}"
			#printf '%s %s %s\n' "$_timeStamp" "${self} ${_cAsk}USER${_cReset}" "${@}" >>${_logFile}
			# don't log prompts...if something is important, log as debug
		}
	# LOG ONLY
	elif [[ $_console = 0 && $_log = 1 ]]; then
		_debug() {
			[[ "$_DEBUG" = "false" ]] && return
			local _timeStamp=$(date +%s.%N)
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cDebug}DEBUG${_cReset}" "${@}" >>${_logFile}
		}
		_info() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cInfo}INFO${_cReset}" "${@}" >>${_logFile}
		}
		_warn() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cWarn}WARN${_cReset}" "${@}" >>${_logFile}
		}
		_error() {
			local _timeStamp=$(date +%s.%N)
			printf '%s %s %s\n' "$_timeStamp" "${self} ${_cError}ERROR${_cReset}" "${@}" >>${_logFile}
		}
		_ask() {
			:
			#local _timeStamp=$(date +%s.%N)
			#printf '%s %s %s\n' "$_timeStamp" "${self} ${_cAsk}USER${_cReset}" "${@}" >>${_logFile}
			# don't log ask prompts
		}
	# CONSOLE ONLY
	elif [[ $_console = 1 && $_log = 0 ]]; then
		_debug() {
			[[ "$_DEBUG" = "false" ]] && return
			printf '%s %s\n' "${_cDebug}DEBUG${_cReset}" "${@}"
		}
		_info() {
			printf '%s %s\n' "${_cInfo}INFO${_cReset}" "${@}"
		}
		_warn() {
			printf '%s %s\n' "${_cWarn}WARN${_cReset}" "${@}"
		}
		_error() {
			printf '%s %s\n' "${_cError}ERROR${_cReset}" "${@}"
		}
		_ask() {
			printf '%s %s' "${_cAsk}USER${_cReset}" "${@}"
		}
	else
		# do nothing
		_debug() { : ; }
		_info() { : ; }
		_warn() { : ; }
		_error() { : ; }
		_ask() { : ; }
	fi
	export -f _debug
	export -f _info
	export -f _warn
	export -f _error
	export -f _ask
}
# create the log functions now...update them later
# this might need to be reconsidered
_fLOG


# HOW to print multi lines when they are detected
#_info() {
#	SAVEIFS=$IFS
#	IFS=$'\n'
#	_pList=(${1})
#	IFS=$SAVEIFS
#	if [[ ${#_pList[@]} -gt 1 ]]; then
#		printf "%s %s\n" "${info}INFO${reset}" "${_pList[0]} "
#		for (( i=1; i<${#_pList[@]}; i++ ))
#		do
#			printf "\t\t: %s\n" "${_pList[$i]} "
#		done
#	else
#		printf "%s %s\n" "${info}INFO${reset}" "${1} "
#	fi
#}


####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

alternate env settings:
 -a <name>  set the germ dir name to <name>
 -w <name>  set the master studio dir to <name> (assumes \$HOME/<name>)

commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database
 inspect             run tig on the germ git bare repo
 sizer               run github sizer tool on germ git bare repo

EOF
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git bare repo,
keeping minimal metadata and organizing with tree objects.

EOF
}

####################################
# PARAMETER PROCESSING FUNCTIONS
####################################

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	# make the original environment available to _shell for calling back into main
	export _originalParameters=${*}
	_debug "${FUNCNAME}: positional parameters read: $*"
	while getopts ":hsdlva:w:" flag ; do
		_debug "${FUNCNAME}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				export _germDirName=$OPTARG
				# TODO find a better way of avoiding using key words as OPTARGs
				[[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
				_debug "using alternative germ name '$_germDirName'"
				;;
			w)
				export _studioDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
				_debug "using alternative studio name '$_studioDirName'"
				;;
 	    s)
				_debug "${FUNCNAME}: enabling silent mode with flag -$flag"
 	      export _SILENT=true
				;;
			d)
				_debug "${FUNCNAME}: enabled debug mode with flag -$flag"
				export _DEBUG=true
				;;
			l)
				_debug "${FUNCNAME}: enabled log mode with flag -$flag"
				export _LOG=true
				;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_debug "${FUNCNAME}: _LOG=${_LOG}"
	_debug "${FUNCNAME}: _SILENT=${_SILENT}"
	_debug "${FUNCNAME}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_debug "${FUNCNAME}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_debug "${FUNCNAME}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_debug "${FUNCNAME}: '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_debug "${FUNCNAME}: '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_debug "${FUNCNAME}: '$1' called"
				_subCommand=$1
				return
				;;
			inspect)
				_subCommand=$1
				return
				;;
			status)
				_subCommand=$1
				return
				;;
			recover)
				_subCommand=$1
				return
				;;
			sizer)
				_subCommand=$1
				return
				;;
			source)
				_subCommand=$1
				return
				;;
			test)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
	# set (and print) the environment
	#_info "setting up environment now"
	export _studioDir="$(dirname ~/.)/${_studioDirName}"
	export _germDir="${_studioDir}/${_germDirName}"
	export _germGitDisk="${_germDir}/.gitdisk"
	export _logFile="${_germDir}/germ.log"
	export _git="--git-dir=${_germGitDisk}"
	export _gitWT="--git-dir=${_germGitDisk} --work-tree=${_germDir}"
	#_gitWT="git --git-dir=${_germGitDisk} --work-tree=${_germDir}"
	#_git="git --git-dir=${_germGitDisk}"
	[[ -f "${_logFile}" ]] && _canLog=true || _canLog=false
	export _canLog
	_debug "self=$self"
	_debug "_studioDirName=$_studioDirName"
	_debug "_studioDir=$_studioDir"
	_debug "_germDirName=$_germDirName"
	_debug "_germDir=$_germDir"
	_debug "_germGitDisk=$_germGitDisk"
	_debug "_logFile=$_logFile"
	_debug "_gitWT=$_gitWT"
	_debug "_git=$_git"
	_debug "git version= $(git $_git -v)"
	_debug "_canLog=${_canLog:-false}"
	_debug "_user=${_user:-unset}"
	_debug "_DEBUG=$_DEBUG"
	_debug "_SILENT=$_SILENT"
	_debug "_LOG=$_LOG"
	_debug "git command: 'git ${_git}'"
	_debug "gitWT command: 'git ${_gitWT}'"
}

_isEnvSufficient() {
	# check for required tools, report accordingly
	# TODO add recommended checks with _missing{0:name,1:name}
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	# check for germ dir (unless we are running create)
	if [ ! -d "${_germDir}" ]; then
		if [ -z "${_subCommand:-}" ]; then
			_error "found no ${_germDir}; run 'germ create' first"
		 	return 1
		elif [ ! ${_subCommand:=} = "create" ]; then
			_error "found no ${_germDir}; run 'germ create' first"
			_sufficient=false
		fi
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}

#################################
# SUBCOMMAND OPTION PROCESSING
#################################

_getAddOpts() {
	# check for _add() flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_debug "${FUNCNAME}: positional parameters read: $*"
	shift
	while getopts ":ib" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_debug "enabled inline mode"
				_inline=true
				;;
			b)
				# bulk add
				_debug "bulk add operation"
				_bulk=true
				;;
			?)
				 _error "${FUNCNAME}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_debug "${FUNCNAME}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_warn "${FUNCNAME}: force mode enabled"
				;;
			?)
				_error "${FUNCNAME}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_debug "${FUNCNAME}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_warn "${FUNCNAME}: force mode enabled"
				;;
			?)
				_error "${FUNCNAME}: unknown flag -$OPTARG"; exit 1
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

#####################################	
# SUBCOMMANDS
#####################################	


####################################
# HEALTH AND STATUS
####################################

# TODO
# for database maintenenace...check for dangling blobs
# brute force
# git gc 

_showStatus() {
	# arg 1 = level [optional]
	# 0 = brief [default]
	# 1 = verbose
	local _level=${1:-0}
	_info  "$(git ${_git} --version)"
	_info "studio name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "germ path: ${_germDir}"
	_info "germ gitdisk: ${_germGitDisk}"
	_info "germ user uuid: ${_user}"
	_info "germ user: $(_printBlob ${_user})"
	_info "'git count-objects --human'"
	_objectCount=$(git ${_git} count-objects --human)
	_info "germ object count: ${_objectCount}"
	_lastCommit=$(git ${_git} rev-parse HEAD)
	_info "last commit: ${_lastCommit}"
	_lastDate=$(git ${_git} --no-pager log -1 --format="%ad (%ah)")
	_info "date of last commit: ${_lastDate}"
}

_status() {
	_info "git version: $(git ${_git} --version)"
	_info "studio dir name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "germ path: ${_germDir}"
	_info "germ gitdisk: ${_germGitDisk}"
	_info "germ user uuid: ${_userUUID:-}"
	_info "germ current source: ${_currentSource:-default}"
	git ${_git} commit-graph verify
	[ $? = 0 ] || _warn "'git commit-graph verify' returned an error"
	_info "'git rev-parse --show-object-format HEAD'"
	git ${_git} rev-parse --show-object-format HEAD
	if [[ $_DEBUG = "true" ]]; then
		_debug "'git ls-tree -r HEAD' (ie what is in the last commit):"
		git ${_git} ls-tree -r HEAD
		_debug "'git ls-files --stage' (ie what is in the index):"
		git ${_git} ls-files --stage
	fi
	_info "'git count-objects --human'"
	git ${_git} count-objects --human
	_info "'git count-objects -vH'"
	git ${_git} count-objects -vH 
	_info "count all git objects:"
	_info "'git cat-file --batch-all-objects --batch-check | wc -l'"
	git ${_git} cat-file --batch-all-objects --batch-check | wc -l
	_info "how many total objects:"
	_info "'find ${_germGitDisk}/objects -type f | wc -l':" 
	find ${_germGitDisk}/objects -type f | wc -l
	_info "git cat-file -p main^{tree}' (ie show tree namespace):"
	git ${_git} cat-file -p main^{tree}
	_info "'git fsck --full'"
	_gitfsck=$(git ${_git} fsck --full)
	_gitFsckExit=$?
	while IFS= read -r line; do
		if [[ $line =~ ^dangling ]]; then
			echo "${yellow}$line${reset}"
		fi
	done <<< "${_gitfsck}"
	_info "git fsck exit status: '${_gitFsckExit}'"
	_gitDiff="git ${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(git ${_git} rev-parse HEAD)
	_inconsistentCount=$(${_gitDiff} | wc -l)
	_info "last commit id: ${_lastCommit}"
	_info "inconsistent count: ${_inconsistentCount}"
	if [[ ${_inconsistentCount} -ne 0 ]]; then
		_warn "'git diff --cached --summary HEAD' results:"
		git ${_git} --no-pager diff --cached --summary HEAD
	fi
	_isIndexClean || _warn "INDEX IS INCONSISTENT"
}


_sizer() {
	cd ${_germGitDisk}
	_debug "pwd $PWD"
	echo "HHH $PWD ${_germGitDisk}"
	git-sizer --verbose
}

_inspect() {
	tig -C${_germGitDisk}
}

# TODO log output formatting
#${_git} log --graph --reflog
# the above runs into a pager and is quite nice and useful already
# the below is someone else's custom formatting
# $ git config --global alias.graph \
#  "log --graph --all --format='%h %s%n        (%an, %ar)%d' --abbrev-commit"

_listTags() {
	git ${_git} ls-files t/*/count.*
}


##################################
# ADD
##################################

_add() {
	local _germString=
	local _commitMsgString=
	local _primaryKey=
	# check if source is set already
	if _isSourceSet; then
		_currentSource=$(_getSource)
	else
		_currentSource="default"
	fi
	# FIX THIS...-i should not require -b
	# -b just means read from stdin...and it can be one or many lines
	if [ ${_inline:-null} = "true" ]; then
		if [ -p /dev/stdin ]; then
			_debug "reading from stdin"
			#while IFS= read line; do
			#	_germString+="${line}"
			#done
			_germString=$(cat)
		else
			[ -z "${_workingParams}" ] && { _error "${FUNCNAME}: 'add -i' cannot contain an empty message"; return 1; }
			_debug "found an inline string: '$_workingParams'"
			_germString="${_workingParams}"
		fi
	else
		_message=$(vipe)
		#_workingParams="${_message}"
		_germString="${_message}"
	fi
	_commitMsgString=$(_buildCommitMsg "${_germString}") || _error "empty commit msg"
	# set up primary key namespace mapping
	_primaryKey=$(_getNewKey) || _error "could not get a new unique key"
	# ADD the BLOB...get the BLOB id
	_blobID=$(git ${_git} hash-object --stdin -w <<< "${_germString}")
	#
	# TURNING THIF OFF
	_readBlob $_blobID 
	#
	# map blob to primary key in a/
	_mapBlob ${_blobID} ${_primaryKey}
	# add blob to the source list in $_currentSource
	_addToSource ${_currentSource} ${_primaryKey}
	# map tags
	_mapTags $_blobID
	# don't commit on each add during a bulk entry
	# some other logic is needed here to confirm the bulk add is over
	if [[ ${_bulk:-} = "true" ]]; then
		:
	else
		_doCommit "${_commitMsgString}"
	fi
# TODO add timer to catch left screen
# TODO use nano for certain functions, vim for others?
}

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	# TODO: consider what to do with tags
	local _maxLength=75
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	[ -z "${_commitMsgString}" ] && return 1
	echo "${_commitMsgString}"
}

# problems include matching a tag '#' if ^'##' is found (as well as other
# non-alpha-numeric characters
_mapTags() {
	# arg 1 = blobID
	# check for tags (hash at first character of line)
	# assumes global _blobArray
	[ $# -ne 1 ] && return 1
	local _blobID=${1}
	local _line
	_emptyBlob=$(git ${_git} hash-object -w --stdin </dev/null)
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			_tag=${_line%% *}
			if [ -z "${_tag:1}" ]; then
				true
			else
				# get the t/TAG/count.NUMBER
				_tagCount=$(git ${_git} ls-files t/${_tag:1}/count.* | cut -f3 -d/)
				if [ -z "${_tagCount}" ]; then
					git ${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/count.1"
				else
					git ${_git} --work-tree=${_germDir} update-index --remove "t/${_tag:1}/${_tagCount}"
					x=${_tagCount#*.}
					((x++))
					_tagCount=count.$x
					git ${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/${_tagCount}"
				fi
				# update the tag-path
				_path="t/${_tag:1}/$_blobID/self"
				git ${_git} update-index --add --cacheinfo 10064,$_emptyBlob,$_path
			fi
		fi
	done
}

############################
# CREATE
############################

_create() {
	# create a new germ database
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_ask "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z "${_studioName}" ] || _studioDirName="${_studioName}"
	_ask "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	_ask "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_ask "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_setEnv
	_info "studio dir name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "germ path: ${_germDir}"
	_info "germ gitdisk: ${_germGitDisk}"
	_info "germ user name: ${_userName}"
	_info "germ user email: ${_userEmail}"
	read -rsn1 -p "$(_ask 'proceed? (y/n)')" _yn
	echo
	[[ "$_yn" != "y" ]] && { _error "aborting"; exit 1; }
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk} || { _error "could not create"; exit 1; }
	else
		gitdisk create -b ${_germGitDisk} || { _error "could not create"; exit 1; }
	fi
	touch ${_logFile}
  git config --global includeif.gitdir:"${_germDir}".path "${_germDir}/.gitconfig"
	git config --file="${_germDir}"/.gitconfig user.name "${_userName}"
	git config --file="${_germDir}"/.gitconfig user.email "${_userEmail}"
	# _user is global var and short
	# _userUUID is blobid and long
	_userUUID=$(_uuidGen "${_userName}:${_userEmail}")
	_user=$(_userAdd "${_userName}:${_userEmail}")
	# map u/uuid/self to blob of git user string "user:email"
	# set /u/uuid/current as empty
	_mapBlob "${_userUUID}" "u/${_user}/self"
	_mapEmpty "u/${_user}/current"
	# write blob, get blobid (hash key)
	_blobID=$(_writeBlob "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)")
	# map blob to a/DATE/uuid.seconds
	#_primaryKey=$(_getNewKey) || _error "could not get a new unique key"
	#_mapBlob ${_blobID} ${_primaryKey}
	_saveSource "default" "default source created by ${self}"
	_setSource "default"
	_doCommit "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

# TIP
# git help --config
# lists all the git config variables
}



# TODO next
# update add()
# add the user
# decide whether to put the user:email blob or use an empty /self
# put the first blob in
# make the _userUUID a global VAR we get and set
# change the a/ path to be a/YEAR/MONTH/DAY/$userUUID.$unixSeconds
#
# add some sanity checks with user management...because the possibility of a
# lost or broken git config risks breaking the whole thing if we rely on the git
# config includeif
# then build _source()
# then put data in and move this to a production state
# much of the recovery functions will have to come in time
# additionally, migrating, merging, etc will have to follow later
# need to move data in and begin testing with actual data for the next phase,
# which is to begin building out the namespace mapping and the viewing,
# browsing, searching, and editing process...including blob naming, blob
# workflows, directory lattice, and project creation



####################################
# GERM PRIMITIVES
#
# _getNewKey		generate the unique filesystem name for the blob: $uuid.$seconds 
# _setUserUUID	set the global var _user
# _userSet 
# _userPrint
# _userAdd
# _doesUserExist
# _uuidGen

_getNewKey() {
	# generate a new unique unix_time key path using date +%s and global _user
	# make sure it is unique...wait a couple seconds...otherwise return 1
	# print the key path
	# used to create all 'germ' blobs
	# not used for metadata
	local _d="$(date +%s.%N)"
	local _unixseconds="$(date +%s)"
	local _u="${_userUUID:0:4}"
	local i=0
	local _source="default"
	#local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_u}.${_d}.txt"
	# playing with tree creation...how much of a difference this will make
	# 1000 germs using the above tree structure:
	# | * Trees 
	# |   * Count                    |  5.01 k   |
	# |   * Total size               |  27.4 MiB |
	# |   * Total tree entries       |   507 k   |
	#
	# the change below makes little difference
	#local _keyPath="a/${_u}.${_d}.txt"
	# TRY using the blob rev-parse id and adding it to the file name
	# $_source/$_user/${_unixseconds:0:8}/${_unixseconds:8}.${_blobID:0:8}.txt
	local _keyPath="${_source}/${_u}/${_unixseconds:0:8}/${_unixseconds:8}.${_d}"
	while _doesKeyExist "${_keyPath}"; do
		sleep 0.5
		((i++))
		if [[ "$i" == '5' ]]; then
			return 1
		fi
	done
	echo "${_keyPath}"
# NB this is the primary key for all data in...the decision to name it as a
# truncated UUID plus the time plus the .txt may have ramifications.
# QUESTION: this is a plain text system; would file suffix ever matter?
# QUESTION: is there any reason to include the suffix in the first place?
# the possibility of collision if/when merging is very low...using 4 characters
}


##########
# _user
##########
# over-engineered multi-user capability
# adaptable...user handle is a variable-length truncated string of a hash
# the multiple users can be pseudonyms (for a single person)
# or many different users
# the master a/ index should always merge cleanly
# the other namespaces may not...by design
# the concept of "identity" and "pseudonym" interact
#
# data
# user name:			string, can contain spaces, upper, lower, digits ?
# email address		string, valid email address
# combined into:	"user name:email address"
# this is the "pseudonym"
#
# external
# git config					supplies seed data
# $HOME/.gitconfig		includeIF statements to:
# $GERM/.gitconfig		contains the git user name(s)	
# 
# global
# _userUUID = full hash of pseudonym ("user name:email address") 
# _user = user "handle" (truncated hash of _userUUID; unique variable-length string)
#
# index
# u/_user/self	-> 	blob containing pseudonym 
# u/*/current		->	empty blob (unique indicator) default
# u/*/alpha			->	empty blob for first user
#
# settings
# _minUserLength		defines the shortest possible _user
# * this may turn out to be a bad design decision unless u/$_user/self is more
# ephemeral...ie if/when an instance is changed from len=2 to len=3
# 
# methods
# _uuidGen				generate the user uuid (_userUUID)
# _doesUserExist	check full _userUUID with _printBlob (no user match)
# _userAdd				using _userUUID, find the shortest match and create user
# _userSet				set the global _user and u/$_user/current
# _userPrint			print user details
#
# use
# git commit messages
# composing as pseudonym or anonymous, eg
# a context that can be used as desired
# main index for blob naming	a/2023/02/08/$_userUUID.$unixseconds
# displayed in shell status line (as "_user")
# can be used to filter
#
# future
# aliasing (to handle email or name change without identity change)

_userSet() {
	# arg 1 = _user [optional]
	# check for global var _user (override)
	# validate this user...return if no such user exists
	local _u
	local _uuid
	# if no arg supplied
	if [ -z "${1:-}" ]; then
		# exit if create is running
		[[ ${_subCommand:-} = "create" ]] && return
		# and if global _user is unset
		if [ -z "${_user:-}" ]; then
			# try to get the user from u/*/current
			_u=$(_getKeyValue u/*/current)
			_uuid=$(_getBlobID u/${_u}/self)
		# _user was set (manually) in the script
		else
			_u=$_user
			if _doesKeyExist "u/${_u}/self"; then
				_uuid=$(_getBlobID u/${_u}/self)
			else
				_warn "$_user is not valid"
				exit
			fi
		fi
	# _user was supplied as $1
	else
		_u=$1
		if _doesKeyExist "u/${_u}/self"; then
			_uuid=$(_getBlobID u/${_u}/self)
		else
			_warn "$_user is not valid"
			exit
		fi
	fi
	export _user=$_u
	export _userUUID=$_uuid
	#_mapEmpty u/$_u/current
	##
	# THIS TOTALLY BREAKS while running a bulk import
	## make it atomic
	#_mapEmpty u/$_u/current
}

_userSave() {
	if _doesKeyExist u/*/current; then
		_existing=$(_getKeyValue "u/*/current")
		_mapEmpty u/$_existing/current.removing
		_mapEmpty u/$_user/current
		_deleteKey u/$_existing/current
		_deleteKey u/$_existing/current.removing
	else
		_mapEmpty u/$_user/current
	fi	
}


_userPrint() {
	# arg 1 = _user [optional]
	local _l_user=${1:-${_user:-unset}}
	local _l_name
	local _l_email
	local _l_us
	_info "supplied: '${1:-}'"
	_info "checking for '${_l_user}'"
	_info "global: _user= '${_user:-unset}'"
	_info "global: _userUUID= '${_userUUID:-NULL}'"
	_info "index: user '${_l_user}' _userUUID= '$(_getBlobID u/${_l_user}/self)'"
	_info "index: 'current' user= $(_getKeyValue u/*/current)"
	_l_us=$(_readKey u/${_l_user}/self)
	_info "index: user name= '${_l_us%%:*}'"
	_info "index: user email= '${_l_us##*:}'"
}

_userAdd() {
	# arg 1 = "user:email"
	# get the userUUID
	# check if the user exists
	# if not, find the shortest user handle
	# add the blob ; get the blobID
	# map the blob
	# check for u/*/alpha
	# mapEmpty if first user
	# _mapBlob /u/$truncation/self -> blobID
	local _minUserLength=4
	local _blobID
	local _userUUID
	local _user
	local _userName
	local _userEmail
	local _userString="${1:-}"
	[ -z "${1:-}" ] && { _warn "no user name supplied" ; return 1 ; }
	# validate user string ( "name string" : "email string")
	_userName="${_userString%%:*}"
	_userEmail="${_userString##*:}"
	[ "${_userString}" = "${_userName}:${_userEmail}" ] || { _warn "'${_userString}' malformed" ; return 1 ; }
	# generate UUID
	_userUUID=$(_uuidGen "${_userString}")
	_doesUserExist "${_userUUID}" && { _warn "'${_userUUID} ${_userString}' exists" ; return 1 ; }
	# write the unique user string
	_blobID=$(_writeBlob "${_userString}")
	# look for shortest user handle
	while _doesKeyExist "u/${_blobID:0:${_minUserLength}}/self"; do
		((_minUserLength=_minUserLength+1))
	done
	# map the user to u/
	_user=${_blobID:0:${_minUserLength}}
	_mapBlob ${_blobID} "u/${_user}/self"
	_doesKeyExist u/*/alpha || _mapEmpty "u/${_user}/alpha" 
	# return the user name
	echo $_user
}

_doesUserExist() {
	# arg 1 = _userUUID (full hash)
	_printBlob "${1}" || return 1
}

_uuidGen() {
	local _u
	local _e
	local userstring
	local uuid
	if [[ -z "${1:-}" ]]; then
		_u=$(git ${_git} config --get user.name &>/dev/null) || return 1
		_e=$(git ${_git} config --get user.email &>/dev/null) || return 1
		userstring="${_u}:${_e}"
	else
		userstring="${1}"
	fi
	uuid=$(echo "${userstring}" | git ${_git} hash-object --stdin)
	echo ${uuid}
}

######################################
# GIT PRIMITIVES
#
# generic git interface functions we use
# _writeBlob			write a blob...return a blobID
#	_readBlob				read a blob into a bash array and export as global var
# _printBlob			print the contents of a blob to stdout
# _mapBlob				add an entry in the index pointing to the blobID
# _mapEmpty				write an empty blob as a key to a path (eg u/$uuid/current)
# _doCommit				commit changes to the repo
# _doesKeyExist		check for an existing key in namespace (eg t/$tag/catalog/x)
# _isIndexClean		check the integrity and state of blobs and maps
# TODO separate _writeBlob and _putBlob?
# _writeBlob should add a key
# _putBlob should only put a blob in and return the blobID
# _getBlobID			given an index, return the blobID
#
# TODO, change all these to return exist status only, and for all data required,
# use the passed variable name from the caller...this way we can enable all
# legacy '_log 0' into _debug statements safely

_getBlobID() {
	# arg 1 = key
	git ${_git} ls-files --stage "${1}" | cut -f2 -d' '	
}

_writeBlob() {
	# arg 1 = blob
	# return blobID
	local blobID
	[ -z "${1:-}" ] && return 1
	blobID=$(git ${_git} hash-object --stdin -w <<< "${1}")
	echo "${blobID}"
	# TODO improve this to avoid errors
	# catch non-zero exit of hash-object and return that value
}

_readBlob() {
	# arg 1 = blob ID
	# read a blob into a bash array
	# export the array into the global environment for further use
	local _blobID=$1
	git ${_git} cat-file -e ${_blobID} &>/dev/null || return 1
	readarray -t _blobArray < <(git ${_git} cat-file -p ${_blobID})
	if [ ${#_blobArray[@]} -ne 0 ]; then
		_debug "found ${#_blobArray[@]} line[s] in the new blob"
		export _blobArray
	else
		_debug "${_blobID} is empty"
		return 1
	fi
# TODO fix this to set the variable passed to it as an arg by the caller instead
# of just setting a global var
}

_printBlob() {
	# arg 1 = blob ID
	# print the contents of the blob to stdout
	git ${_git} cat-file -p ${1} 2>/dev/null || return 1
}

_mapBlob() {
	# arg 1 = blobID (full sha)
	# arg 2 = path
	[[ -z "${1:-}" || -z "${2:-}" ]] && return 1
	git ${_git} update-index --add --cacheinfo 10064,"${1}","${2}"
}

_mapEmpty() {
	# arg 1 = path
	[ -z "${1:-}" ] && return 1
	_emptyBlob=$(git ${_git} hash-object -w --stdin </dev/null)
	git ${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"${1}"
# NOTE this is a functional equivalent of git add --intent-to-add, with the
# exception that command expects a work-tree, while we have none
}

_doCommit() {
	# discrete operation...write the index as a commit
	_commitMsg="${1}"
	_tree=$(git ${_git} write-tree)
	# next make sure there is a parent
	if git ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(git ${_git} rev-list -n1 --all HEAD)
		_commit=$(git ${_git} commit-tree $_tree -p $_parent -m "$_commitMsg")
	else
		_commit=$(git ${_git} commit-tree $_tree -m "[genesis] ${_commitMsg}")
	fi
	git ${_git} update-ref HEAD "${_commit}"
	return 0
}	

_doesKeyExist() {
	# arg 1 = key (namespace path)
	# return 0 if true
	# return 1 if false (no key exists)
	git ${_git} ls-files --error-unmatch "${1}" &>/dev/null || return 1
}

_isIndexClean() {
	git ${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
# TODO
# improve this
# 1. report on a/ for blob changes
# 2. check for state (ie changed source)
# TODO change this from checking the index whole to checking:
# a/ for dropped (dangling) blobs
# ie ignore c/ which icludes state...which we can tolerate
}


################
# SOURCE
################

# source is an exclusive category...an entity (blob or germ) cannot be a member
# of more than one source.  an entity can be without a source (ie source=null)
# it can also be called 'context'
# the 'source' is a generic organizing category and can be used in a variety of
# ways.  when it is set, all new germ entries will be cataloged (logged) into
# the source log c/$source/self.catalog
# the source catalog file:
# a non-sorted list of blobs added to the 'category'
#
# methods
# _addToSource		add a blob (key: a/2022/10/01/$uuid.$seconds) to
# c/$source/self.catalog file
#
# future
# add a source "type" value
# c/$source/self.type (or type.VALUE and use emptyblob)
# eg, indexcards, notebook, lecture, marginalia, loose, iphone, etc

_addToSource() {
	# arg 1 = source name
	# arg 2 = key to blob
	local _cat=
	local _id=
	#_doesKeyExist c/${1}/self.catalog && _currentCat=$(_getBlobID "c/${1}/self.catalog")
	if _doesKeyExist c/${1}/self.catalog; then
		_currentCat=$(_getBlobID "c/${1}/self.catalog")
		_cat=($(_printBlob "${_currentCat}"))
	else
		_cat=()
	fi
	_cat+=(${2})
	_id=$(_writeBlob "$(printf '%s\n' ${_cat[@]})")
	_mapBlob "${_id}" "c/${1}/self.catalog"
}

_getSource() {
	# print the current SOURCE
	# read c/SOURCE/current
	x=$(git ${_git} ls-files c/*/current)
	x=${x#c/*}
	x=${x%/*}
	#[[ -z "${x}" ]] && echo "null" || echo "${x}"
	echo ${x}
	# this prints empty string if no source...printing null is not a good idea,
	# instead, change behavior above
}

_test() {
	_getSource
}

_isSourceSet() {
	# no args
	# check for c/*/current
	# return 0 if true
	# return 1 if false
	_doesKeyExist c/*/current
}

_isSourceNew() {
	# arg 1 = new source name
	# checks for c/$1/self
	# if it exists, return 1 (no it is not new)
	# if it does not exist, return 0 (yes it is new)
	! _doesKeyExist "c/${1}/self"
}

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	_isSourceSet && _deleteKey "c/*/current"
	# THIS WILL BE PROBLEMATIC AS IT IS NOT ATOMIC
	_mapEmpty "c/${1}/current"
	#_doCommit "[source] made ${1} current"
	export _currentSource=${1}
}

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	_id=$(_writeBlob "${1}")
	_mapBlob "${_id}" "c/${1}/self"
	_desc=$(_writeBlob "${2}")
	_mapBlob "${_desc}" "c/${1}/self.description"
	#_doCommit "[source] added ${1}"
}

# germ methods required
# _getKeyValue (boolean)
# _deleteKey
# _readKey
# _listKeys
# _updateKey
#
# germ Bkey is a boolean or binary flag which indicates something
# it is exclusive in its namespace...ie c/*/NAMESPACE can only contain one Bkey
# its first use is with indicating the current user u/$UUID/current
# it also is used to indicate the current notebook source with c/$SOURCE/current
# it uses _mapEmpty to map an empty blob
# it refers to its parent directory in the namespace
# METHODS USED
# _doesKeyExist		(git)
# _deleteBkey			(germ bkey)
# _insertBkey			(germ bkey)
# _getBkeyValue		(germ bkey)
#
# germ Key is used similarly except that it contains information beyond an
# exclusive boolean setting
# ex. u/$UUID/self points to a blob from which the $UUID is derived, the string
# contianing the "user name:user email" used by git
# the information in the blob to which self points is arbitrarily defined by the
# use...u/*/self --> "user name:user email"
# c/*/self --> "source name"
# additionally, a key can contain additional attributes, eg c/*/self.description
# which contains the user-supplied description of the source
# the self key is used to enforce uniqueness and map into namespace the
# truncated hash
#
# METHODS USED
# _doesKeyExist
# _readKey
# _listKeyAttributes
# _updateKey

_getKeyValue() {
	# arg 1 = key eg c/*/current
	# prints value from c/$value/$key
	git ${_git} ls-files "${1}" | cut -f2 -d/
}

_getKeyList() {
	# arg 1 = key space eg c/$source/self.*
	git ${_git} ls-files "${1}" | cut -f3 -d/
}

_deleteKey() {
	# arg 1 = key
	git ${_git} --work-tree=${_germDir} rm --cached --quiet "${1}"
	# THIS SHOULD be made more discrete
	# this REMOVES all keys!!!
}

_readKey() {
	# given key, eg c/$source/self.description
	# get the blob id
	# print the blob
	local _blobid
	_blobid=$(git ${_git} ls-files --stage ${1} | cut -d' ' -f2)
	if [ -z ${_blobid} ]; then
		echo "error, blob does not exist"
	else 
		_printBlob ${_blobid}
	fi
}
# exporting these functions to give fzf access to them
export -f _readKey
export _git
export -f _printBlob
export -f _doesKeyExist

_getSourceList() {
	# create a list from c/*/self
	git ${_git} ls-files --stage c/*/self | cut -f2 -d/
}

_printSourceEntities() {
	# arg 1 = source
	if _doesKeyExist c/${1:-}/self.catalog; then
		_readKey c/${1}/self.catalog
	else
		return 1
	fi
}
export -f _printSourceEntities

_getSourceCount() {
	# arg 1 = source
	local _count=0
	_count=$(_printSourceEntities ${1} | wc -l)
	echo "$_count"
}
export -f _getSourceCount

# source methods
# _isSourceSet		check for c/*/current
# _getSource			return c/$source/current
# _setSource			remove c/*/current (if set) and add c/$source/current 
# _addSource			user dialog to add new and (optionally) set current
#
# source name: eg lgb-12Jan2023
# source description: arbitrary text describing source


# TODO consider adding a super-set (like binding old notebooks into one)
# TODO add delete, rename, merge, and split
#
# TODO future _source operations...merge notebooks, split notebooks, archive,
# and print
#
# TODO add a list of disallowed names eg ("unset") which we use internally
_source () {
	local _currentSource=""
	export _maxLength=25
	export _minLength=1
	# check if source default is set already
	if _isSourceSet; then
		_currentSource=$(_getSource)
	else
		_currentSource="default"
	fi
	######################
	#### MAIN MENU
	######################
	_mainMenu() {
	local _mainSelection
	_showOptions() {
	if [[ ${_currentSource} = "default" ]]; then
		_displaySource="${yellow}default${reset}"
	else
		_displaySource="${green}${_currentSource}${reset}"
	fi
	_sc=$(_getSourceCount ${_currentSource})
	if [[ ${_sc} = 0 ]]; then
		_sourceCount="${yellow}${_sc}${reset}"
	else
		_sourceCount="${green}${_sc}${reset}"
	fi
	echo -ne "
    current source: ${_displaySource} [${_sourceCount}]

    c) change current source
    s) show details
    l) list entities
    e) edit description
    r) rename current source
    a) add new source
    m) merge two sources (future)
    ?) help
    q) return to germ

"
	}
	_showOptions
	_previewSource() {
		# used by fzf during source change...shows description and entity count
		echo "source: $1"
		echo "entities: $(_getSourceCount $1)"
		echo
		echo "----DESCRIPTION-------------------"
		_readKey c/$1/self.description
	}
	export -f _previewSource
	_chooseSource() {
		# fzf-based chooser function
		local _newSourceName
		local _fzfPrompt="--prompt=TYPE-TO-FILTER> --info=hidden"
		local _fzfColor="--color=bg:#222222,preview-bg:#333333,header:yellow"
		local _fzfHeader="--header=choose from the list above"
		local _fzfPreview="--preview=_previewSource {} --preview-window=50%"
		local _fzfBack="--bind=backward-eof:clear-query"
		#local _fzfEsc="--bind=esc:cancel --bind=enter:accept-non-empty --bind=ctrl-c:cancel"
		local _fzfEsc="--bind=esc:cancel --bind=enter:accept-non-empty"
		_newSourceName=$(_getSourceList | fzf ${_fzfBack:-} ${_fzfEsc} ${_fzfPrompt} "${_fzfColor}" "${_fzfHeader}" "${_fzfPreview}")
		echo ${_newSourceName}
	}
	while read -r -s -n 1 -p"$(_ask 'enter selection [? for help]') " _mainSelection; do
	# with or without readline makes or breaks this shell
	#while read -r -e -s -n 1 -p"$(_ask 'enter selection [? for help]') " _mainSelection; do
		echo	# curious problem here...using the _ask log function may not be the right decision
		case $_mainSelection in
 			c)
				_setSource $(_chooseSource) || _warn "aborted source change"
				_showOptions
				;;
			s)
				_info "current source: ${_currentSource}"
				_info "description: $(_readKey c/${_currentSource}/self.description)"
				;;
			e)
				_newDescription=$(_readKey "c/${_currentSource}/self.description" | vipe)
				_id=$(_writeBlob "${_newDescription}")
				_mapBlob "${_id}" "c/${_currentSource}/self.description"
				_doCommit "[source] updated ${_currentSource} description"
				_showOptions
				;;
			a)
				_addSource
				_showOptions
				;;
			l)
				_debug "current source= ${_currentSource}"
				_info "entities   : $(_printSourceEntities ${_currentSource})"
				;;
			m)
				_warn "merge is a future feature...promise"
				;;
			r)
				_renameSource "${_currentSource}"
				_showOptions
				;;
			q)
				return
				;;
			h|\?)
				_info "use 'source' to add and manage media source list"
				_info "eg, naming notebooks, sets of papers, etc"
				_info "a notebook name is used as a virtual category"
				_showOptions
				;;
			$'\e')
				#_warn "escape key detected"
				# read and ignore escape sequences (including esc)
				read -rsn1 -t .002 tmp || { _warn "esc key not allowed" ; continue ; }
				#read -rsn1 -t .002 tmp || { _warn "esc key allowed" ; return ; }
				if [[ "$tmp" == "[" ]]; then
					read -rsn1 -t .002 tmp || _warn "can't read any more"
					case "$tmp" in
						# ignore arrow keys
						"A"|"B"|"C"|"D") { _warn "arrow keys not allowed" ;  } ;; 
						# ignore insert and delete
						"2"|"3") { _warn "insert and delete keys not allowed" ; } ;; 
						# ignore home and end
						"H"|"F") { _warn "home and end keys not allowed" ; } ;; 
						# ignore all the rest
						*) { _warn "key '$tmp' not allowed" ; } ;;
					esac
				else
					_warn "ignoring escape key '$tmp'"
				fi
				# flush out stdin if necessary
				read -rsn6 -t .002 || continue 
				;;
			$'\177')
				# catch control characters
				_warn "control character detected; ignoring"
				continue
				;;
			$'\04')
				printf %s "${#_mainSelection} character "
				(export LC_ALL=C; printf '%s\n' "made of ${#_mainSelection} byte(s) was read")
				_warn "ctrl-d detected ['${_mainSelection}']"
				#read -rsn6 -t .002 || continue 
				continue
				;;
			?)
				_warn "wrong selection ['${_mainSelection}']; try again"
				;;
			esac
		done
	}

	##########################
	### MENU FUNCTIONS
	##########################
	_addSource() {
		local _newSourceName
		_interactiveSourcePicker _newSourceName
		# BUG...named a source 'a' and it passed
		_isSourceNameValid "${_newSourceName}" || { _error "invalid"; return; } 
		[[ -z ${_newSourceName:-} ]] && return
		[[ ${_newSourceName} = ${_currentSource} ]] && return
		while read -r -e -p "$(_ask "enter a description for '${_newSourceName}': ")" _newSourceDescription; do
			case "${_newSourceDescription}" in
				help|h|\?)
					_info "enter a description for '${_newSourceName}'"
					_info "example: little green notebook 12 Jan 2023" 
					_info "example: lecture notes from chem 202"
					_info "note: the description can be changed later"
					_info "    : multiple lines can be added later as well"
					_info "usage: q to abort, h for this help."
					_info "enter a description for '${_newSourceName}': "
					;;
				quit|q)
					_warn "aborting; '${_newSourceName}' not added. try again later"
					return
					;;
				*)
					[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; continue; } 
					[[ ${_newSourceDescription} =~ ^[[:alnum:]] ]] || { _warn "use your words"; continue; }
					break
					;;
			esac
		done
		# ctrl-d (eg) will break the above loop...catch it here instead
		[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; return; } 
		while read -r -e -n1 -p "$(_ask "save '${_newSourceName}' as a new source? (y/n)") " _c; do
			case ${_c} in
				y)
					_saveSource "${_newSourceName}" "${_newSourceDescription}"
					break
					;;
				n)
					return
					;;
				*)
					continue
					;;
			esac
		done
		while read -r -e -n1 -p "$(_ask "set '${_newSourceName}' as current? (y/n) ") " _d; do
			case ${_d} in
				y)
					_setSource "${_newSourceName}"
					return
					;;
				n)
					return
					;;
				*)
					continue
					;;
			esac
	done
	}

	_renameSource() {
		local _oldName="${1}"
		local _newName
		_interactiveSourcePicker _newName "${1}"
		[[ -z ${_newName:-} ]] && return
		_id=$(_writeBlob "${_newName}")
		_mapBlob "${_id}" "c/${_newName}/self"
		for i in $(_getKeyList "c/${_oldName}/self.*"); do
			_blobID=$(_getBlobID "c/${1}/${i}")
			_mapBlob "${_blobID}" "c/${_newName}/${i}"
			_deleteKey "c/${_oldName}/${i}"
		done
		_setSource "${_newName}"
		_deleteKey "c/${_oldName}/self"
	}

	_interactiveSourcePicker() {
		# smaller function...one job...pick a new source name
		# need to modify for better variable passing
		# arg 1 = caller's variable name
		# arg 2 = default value [optional]
		# ie we tell the function what variable to set
		local __name="${1}"
		local __default="${2:-}"
		_validateName(){
			# function used within fzf preview window to assist in the selection of a
			# source name
			local _newSourceName
			local lengthStatus
			local avail
			local allowedChars="n/a"
			local lead="n/a"
			local last="n/a"
			local repeat="n/a"
			local acceptable="NO"
			_cStat() {
				# arg 1 = key word
				# print the key word in a set color
				[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
				[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
				[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
				echo -n "${1}"
				tput sgr0 
			}
			# export to fzf for --preview
			export -f _cStat
			# validate the name first
			#if [[ ${#1} -lt 3 ]]; then
			if [[ ${#1} -lt ${_minLength} ]]; then
				lengthStatus="TOO SHORT"
				avail="n/a"
			elif [[ ${#1} -gt ${_maxLength} ]]; then
				lengthStatus="TOO LONG"
				avail="n/a"
			else
				lengthStatus="OK"
				_doesKeyExist c/${1}/self && { avail="NO" ; acceptable="NO" ; } || { avail="YES" ; acceptable="YES"; }
			fi
			[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
			[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
			# print the validation info into the fzf preview window	
			echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
			[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
			printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
			printf "unique: %36s\n" "$(_cStat "${avail}")"
			printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
			printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
			printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
			printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
			echo "-----------RULES------------------"
			echo "the name must be unique"
			echo "max length is ${_maxLength}, min is ${_minLength}"
			echo "lower case and numbers only"
			echo "non alpha-numeric characters allowed:"
			echo " - dash (-)"
			echo " - underscore (_)"
			echo " - dot (.)"
			echo " ^ these cannot be first or last"
			echo " ^ cannot be repeated (eg --)"
			echo
			echo "------SELECTED SOURCE DESCRIPTION------------"
			_readKey c/${2}/self.description
		}
		# export function to fzf for --preview
		export -f _validateName
		local _fzfFalse="fzf --bind=enter:print-query --print-query --exact "
		local _fzfPrompt="--prompt=TYPE-NEW-NAME> --info=hidden"
		local _fzfColor="--color=bg:#222222,preview-bg:#333333,header:yellow"
		local _fzfHeader="--header=existing above, guidance right >"
		local _fzfPreview="--preview=_validateName {q} {} --preview-window=50%"
		local _fzfBack="--bind=backward-eof:change-prompt(ENTER-NEW-NAME>)"
		local _fzfEsc="--bind=esc:clear-query"
		# seed with 'sample' if this is the first
		_doesKeyExist c/* || local _fzfSeed="--query=sample"
		# seed with a name if it was provided as $2
		[[ ${__default} ]] && local _fzfSeed="--query=$__default"	
		# this fzf command allows us to use as a "reverse" or false finder...ie we
		# use the fzf results to show a list from which we cannot choose one of the
		# already existing members of the list
		while true; do
			_newSourceName=$(_getSourceList | ${_fzfFalse} ${_fzfBack} ${_fzfEsc} ${_fzfPrompt} ${_fzfSeed:-} "${_fzfColor}" "${_fzfHeader}" "${_fzfPreview}")
			if _isSourceNameValid "${_newSourceName}"; then
				read -r -s -n 1 -p "$(_ask "'${_newSourceName}' is valid, create? (y/n/q) ")" _ynq
				echo
				[[ "${_ynq:-}" = "y" ]] && break
				[[ "${_ynq:-}" = "q" ]] && return
				[[ "${_ynq:-}" = "n" ]] && continue
			else
				_error "'${_newSourceName}' is not a valid name"
				_ask "try again? (y/n) "
				read -r -s -n1  _yn
				echo
				[[ "${_yn:-}" = "y" ]] && continue
				[[ "${_yn:-}" = "n" ]] && return
			fi
		done
		eval ${__name}=${_newSourceName}
	}

	_isSourceNameValid() {
		# arg 1 = source name
		#if [[ "${1}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){3,${_maxLength}}$ ]]; then
		if [[ "${1}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){${_minLength},${_maxLength}}$ ]]; then
			[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
			[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
			[[ "${1}" =~ ([.]|[-]|[_]){2} ]] && return 1
			if _isSourceNew "${1}"; then
				return 0
			else
				_warn "'${1}' is not new"
				return 1
			fi
		else
			_warn "'${1}' is not allowed, try again"
			_warn "rules: a-z A-Z 0-9 _ - allowed; no spaces allowed"
			_warn "rules: max length ${_maxLength} characters, min is ${_minLength}"
			return 1
		fi
	}
	_mainMenu
}

_test() {
	set -x
	local session
	export IGNOREEOF=10
	session="studio-${_user}"
	tmux new-session -d -s $session
	tmux rename-window -t "${session}":0 "${self}"
	tmux send-keys -t "${session}":0 'echo > "${self} prompt here"' C-m
	tmux new-window -t "${session}":1 "dsink"
	tmux attach-session -t "${session}"
}


###############
###### SHELL
###############

# TODO add trap to commit changes when shell exits (ie commit a session)

_shell() {
	# enter (cd) into studio environment
	# change the command history file
	# change the prompt dynamically
	# create a session id
	# create a new branch
	cd "${_studioDir}" || { _error "can not enter studio"; return 1; }
	HISTFILE="${_studioDir}/.germ_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _p
	local _dirty
	local _session="${_user}.$(date +%s)"
	git ${_gitWT} switch -c ${_session}
	# track down how ctrl-d continues to function
	
	# confirm exit function
	_confirmExit() {
		_ask "quit germ? press ${label}y${reset} to quit"
		while read -r -s -n 1  __confirm; do
			echo
			case ${__confirm} in
				y)
					_debug 'git ${_gitWT} switch main'
					git ${_gitWT} switch main
					_debug 'git ${_gitWT} merge ${_session}'
					git ${_gitWT} merge ${_session}
					_debug 'git ${_gitWT} branch -d ${_session}'
					git ${_gitWT} branch -d ${_session}
					_isIndexClean || _doCommit "[${self}] $(date) closed session"
					trap - EXIT
					trap - SIGINT
					cd $OLDPWD
					exit 0
					;;
				*)
					_mainPrompt
					;;
			esac
		done
	}
	# print welcome function
	_displayWelcome() {
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

germ: type ${green}help${reset} for guidance
      type ${red}stop${reset} to leave

HEREDOC
	}
	# print usage
	_printShellUsage() {
		cat << EOF

  add        add a new germ entry
  list       list the tag catalog
  status     show germ health
  inspect    run tig to inspect repo
  source     add and manipulate source
  stop       exit studio
  help       print this message

EOF
	}
	# main shell prompt function
	_mainPrompt() {
	#
	# ignore ctrl+\ ctrl+z and ctrl+c
	trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
	# catch ctrl-d and run _confirmExit
	trap _confirmExit EXIT
	_p() {
		# sets the prompt
		# colors cannot derive from tput here...as 'read -e' becomes confused
		reset=$'\001\e[0m\002'
		red=$'\001\e[00;31m\002'
		yellow=$'\001\e[00;33m\002'
		green=$'\001\e[00;32m\002'
		_cH=$'\001\e[00;45m\002'
		_cG=$'\001\e[00;7m\002'
		_cU=$'\001\e[00;32m\002'
		_cS=$'\001\e[00;33m\002'
		_dirty="${green}o${reset}"
		_isIndexClean || _dirty="${red}-${reset}"
		_cs=$(_getSource)
		echo -n "${_cH}${_studioDirName}${reset}:${_cG}${_germDirName}${reset} ${_cU}${_user}${reset} [${_cS}${_cs}${reset}] ${_dirty} > "
	}
	local __input
	while IFS='' read -r -d $'\n' -p "$(_p)" -e __input; do
	#while read -r -d $'\n' -p "$(_p)" -e __input; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ ${__input} == $'\e' ]]; then
			_warn "no escape" && true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			_confirmExit
		elif [[ "${__input}" =~ (^help$|^h$|^\?$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_listTags
		elif [[ "${__input}" =~ ^git ]]; then
			_gitCommand=(${__input})
			git ${_gitWT} ${_gitCommand[@]:1} || :
		elif [[ "${__input}" =~ (^status$|^stat$) ]]; then
			_showStatus
			_isIndexClean || _warn "DIRTY INDEX"
		elif [[ "${__input}" =~ (^add$|^a$) ]]; then
			eval "${self}" "${_originalParameters}" add || true
		elif [[ "${__input}" =~ (^source$|^s$) ]]; then
			_source
		else
			printf %s "${#__input} character"
			(export LC_ALL=C; printf '%s\n' "made of ${#__input} byte(s) was read")
			eval "${self}" "${_originalParameters}" "${__input}" || :
		fi
	done
	}
	_displayWelcome
	_mainPrompt
}	

###########################
# trap and signal catching

_irishExit() {
	echo #to clear line...this is a bit ugly
	# this function does not behave as desired
  _ask "ctrl-c detected; to resume, press R, to quit, press ENTER"
  while read -s -t 15 -n 1 _ANS; do
		echo
  	if [[ ${_ANS:-n} = 'R' ]]; then
			_info "resuming"
    	return
  	else
   	#_error "user requested exit with ctrl-c"
			_error "goodbye"
			exit 1
		# this seems to fuck up my terminal???
  	fi
	done
}

__irishExit() {
	echo #to clear line...this is a bit ugly
	# this function does not behave as desired
  _ask "ctrl-c detected; to resume, press R, to quit, press ENTER"
  read -s -t 15 -n 1 _ANS
	echo
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
		_info "resuming"
  else
   	#_error "user requested exit with ctrl-c"
		exit 1
		# this seems to fuck up my terminal???
  fi
}
main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_debug "${FUNCNAME}: parameters read: ${*}"
	_debug "${FUNCNAME}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
	_debug "${FUNCNAME}: _subCommand: ${_subCommand:-}"
	_debug "${FUNCNAME}: remaining args: $_workingParams"
	# setup the environment after processing all command line parameters
	_setEnv
	# reinitialize log functions after processing all command line options
	_fLOG
	# validate the environment
	_isEnvSufficient || { _error "cannot run until these problems are resolved"; return 1; }
	# set the global _user vars
	_userSet
	# run germ shell if no arguments
	[ -z "${_subCommand:-}" ] && _shell
	# ctrl-d exits out of the last command...the trap set in the _shell catches
	# the EXIT signal, and runs.  but by now, we're toast.  ctrl-d must be caught
	# earlier in order to be able to pass the commands back to the master script.
	# it's a handy trick but may be unnecessary
	# otherwise, pass the commands to the called "command"
	_debug "now calling the eval to run '${_subCommand:-}'"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}" || exit
}
main "${@}"
