#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us
# derived from a working copy of dsink

# TO MY FUTURE SELF
# WHOSE MEMORY WILL STRUGGLE TO REMEMBER HOW THIS THING WORKS
# TOC MORE OR LESS:
# SCRIPT AND SHELL SETTINGS
# ENVIRONMENT SETTINGS
# DEFAULTS
# BASIC LOGGING FUNCTIONS
# HELPER FUNCTIONS
# PARAMETER PROCESSING FUNCTIONS
# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
# MAIN ENTRY AND CONTROL

# SCRIPT AND SHELL SETTINGS

# bash makin-it-hard settings
set -o errexit
set -o nounset
set -o pipefail

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(git gitdisk dsink tig vipe)


# ENVIRONMENT SETTINGS


# BEHAVIOR

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses normal output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=true

# OUTPUT

# some color
red=$(tput setaf 1)
#boldred=$(tput bold; tput setaf 1)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
prompt=$(tput setab 5; tput setaf 7)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)

# DEFAULT SETTINGS

# WORKING ENVIRONMENT
_studioDirName=studiodev
_studioDir="$(dirname ~/.)/${_studioDirName}"
# GERM lives inside studio (the master container)
_germDirName=germ
_germDir="${_studioDir}/${_germDirName}"
_germGitDisk="${_germDir}/.gitdisk"
_logFile="${_germDir}/germ.log"

# global variables we use
self=$(basename $0)
# check if a logfile exists
[ -f "${_logFile}" ] && _canLog=true || _canLog=false

_prompt() {
	# hack to avoid fixing _log and include a PROMPT type
	# TODO: add this idea into _log to keep the "universal" claim
	echo -n "${prompt}USER${reset}: ${1} "
}

# LOGGING 

_log() {
	# global prompt and logging function
	# consults _DEBUG _SILENT and _LOG for behavior
	# TODO: add type for user PROMPT (ie USER interaction)
	# TODO: try and optimize...many calls for each log event (although the use
	# would never be bogged down since this is a single user system)
	# levels:
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true (and
	# there are functions (eg _format) that should never be SILENT)
	# set to 0 to force all logs into DEBUG pipeline
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	#local _canLog
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	# TODO: fix this...not using it as designed
	#declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	#declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	#local _level=${_i[${_logLevel}]}
	#local _color=${_c[${_logLevel}]}
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	# BUG HERE
	# if SILENT is true and _log = 4, then we don't exit as expected on FATAL
	# error
	if [ ${_SILENT} = true ] && [ ${_logLevel} = 4 ]; then
		exit 1
	elif [ ${_SILENT} = true ]; then
		return
	fi
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: $self ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: $self ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: $self ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: $self ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: $self ${_logMessage}" && exit 1
	fi
}


# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database

for command specific usage, eg:
$ germ help add

EOF
exit 0
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git repo, keeping
minimal metadata and organizing with tree objects

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				_germDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_germDir="$(dirname ~/.)/studio/${_germDirName}"
				_logFile="${_germDir}/germ.log"
				_log 0 "${FUNCNAME[0]}: using alternative germ dir $_germDir"
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			*)
				_log 4 "_getSubcommand(): '$1' is not a subcommand"
				;;
		esac
		shift
	done
}	


_isEnvSufficient() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		fi
	done
	# check for germ dir (unless we are running create...this could use some
	# cleaning for clarification)
	if [ ! -d "${_germDir}" ] && [ ! ${_subCommand} = "create" ]; then
		_log 3 "found no ${_germDir}; run 'germ create' first"
		_sufficient=false
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}


# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
_getAddOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":i" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_log 0 "enabled inline mode"
				_inline=true
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	
# germ add
# two options
#		inline (invoked by add -i)
#			no tags allowed, naturally (bash interprets # as a comment)
#			tags allowed if escaped ("add -i \#<tag> followed by the entry")
#		buffer (add without args, calls an editor, the saved results comprise)
#			
# SUB COMMANDS

__list() {
	local _gitdir="${_germGitDisk}"
	local _git="git --git-dir=${_gitdir}"
  { ${_git} rev-list --objects --all
  ${_git} rev-list --objects -g --no-walk --all
  ${_git} rev-list --objects --no-walk \
        $(${_git} fsck --unreachable |
          grep '^unreachable commit' |
          cut -d' ' -f3)
}
}

_list() {
	local _gitdir="${_germGitDisk}"
	local _git="git --git-dir=${_gitdir}"
	_log 1 "git 'ls-files -s'"
	${_git} ls-files -s $_workingParams
	# HACKED now
	_log 1 "git 'ls-tree -r HEAD'"
	${_git} ls-tree -r HEAD $_workingParams
}

# NAMESPACE construction
# /a/		primary namespace key
#				YEAR/MONTH/DAY/UNIX_SECONDS
#				eg 2023/01/30/1675101655
# /b/		workflow status
#					new			:	added only
#					read		: viewed at least once
#					edited	: edited at least once
#					other operations: move, rename, delete ?
# thus, after adding one, then viewing it:
# /b/add/
# /b/read/1675101655
# /b/edited/
# each blob moves through namespaces following action on the blob
#
# /c/		source (a catalog of notebooks, etc, from whence the germ came)
# /d/		first word catalog
# /e/		tag catalog
# /f/		heuristic
#					matches /d and /e keywords from text and maps them
#					matches text indicators (cf, re, eg, ie, todo, etc)
#					matches operators (<,>,=,+,*,@,$...etc) [future]

_add() {
	# $_workingParams contains the string...we need to check if this is null as
	# some characters (like #) will be stripped out by bash unless we escape it.
	if [ ${_inline:-null} = "true" ]; then
		_log 1 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 4 "'add -i' cannot contain an empty message"
	else
		_message=$(vipe)
	fi
	echo $_message
	_workingParams="${_message}"
	# set up primary key namespace mapping
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_key}"
	# set up git command
	local _git="git --git-dir=${_germGitDisk}"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_workingParams}")
	_log 1 "added the blob to the object store"
	# READ the blob back...first confirmation
	# plus we will parse the blob now to build the metadata view
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
	# testing multiple lines
	#_log 1 "added a new line (for testing purposes)"
	#_blobArray+=("#germ how to catch a hash in the first word")
	#_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
	# UPDATES the index (ie maps blob to namespace...hashed date - key is seconds)
	${_git} update-index --add --cacheinfo 10064 $_blobID ${_keyPath}
	_log 1 "added ${_blobID} as ${_keyPath}"
	# map first word on first line to d/
	_firstWord=${_blobArray[0]%% *}
	${_git} update-index --add --cacheinfo 10064 $_blobID d/${_firstWord}/${_key}
	_log 1 "mapped ${_blobID:0:5} as ${_key} in d/${_firstWord}"
	# check for tags on first line
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			_tag=${_line%% *}
 			_log 0 "found tag ${_tag:1}"
			${_git} update-index --add --cacheinfo 10064 $_blobID e/${_tag:1}/${_key}
			_log 1 "mapped ${_blobID:0:5} as ${_key} in tag space e/${_tag:1}"
		fi
	done
	# next create a tree object from the index
	_tree=$(${_git} write-tree)
	_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
		_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_workingParams")
	else
		_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_workingParams}")
	fi
	_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	_log 1 "updated the HEAD reference"
	return 0
}

# git ls-files is the correct way to navigate the git tree we are creating here


# WORKING ENVIRONMENT
_studioDirName=studiodev
_studioDir="$(dirname ~/.)/${_studioDirName}"
# GERM lives inside studio (the master container)
_germDirName=germ
_germDir="${_studioDir}/${_germDirName}"
_germGitDisk="${_germDir}/.gitdisk"
_logFile="${_germDir}/germ.log"

_create() {
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_prompt "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z ${_studioName} ] || _studioDirName="${_studioName}"
	_prompt "enter studio path ["${_studioDir}"] "
	read _studioPath
	[ -z ${_studioPath} ] || _studioDir="${_studioPath}"
	_prompt "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	_prompt "enter germ gitdisk name ["${_germGitDisk}"] "
	read _germGit
	[ -z ${_germGit} ] || _germGitDisk="${_germGit}"
	# ask if user prefers a different username and email
	_prompt "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_prompt "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_log 1 "${_studioDirName}"
	_log 1 "${_studioDir}"
	_log 1 "${_germDir}"
	_log 1 "${_germGitDisk}"
	_log 1 "${_userName}"
	_log 1 "${_userEmail}"
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk}
	else
		gitdisk create -b ${_germGitDisk}
	fi
  git config --global includeif.gitdir:"${_studioDir}".path "${_studioDir}/.gitconfig-studio"
  git config --global includeif.gitdir:"${_germGitDisk}".path "${_studioDir}/.gitconfig-studio"
	git config --file="${_studioDir}"/.gitconfig-studio user.name "${_userName}"
	git config --file="${_studioDir}"/.gitconfig-studio user.email "${_userEmail}"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

}


_irishExit() {
  echo -ne "\r${yellow}WARNING${reset}: ctrl-c detected; to resume, press R, to quit, press ENTER\n"
  read -s -t 15 -n 1 _ANS
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
  else
    _log 4 "user requested exit with ctrl-c"
  fi
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
  # if run without arguments, run and print _status
	[ -z "${_subCommand:-}" ] && _printUsage
	_log 0 "${FUNCNAME[0]}: _subCommand: $_subCommand"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# validate the environment first
	_isEnvSufficient || _log 4 "cannot run until these problems are resolved"
	# do it
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

