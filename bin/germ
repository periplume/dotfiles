#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# SCRIPT AND SHELL SETTINGS
set -o errexit
set -o nounset
set -o pipefail

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(git gitdisk dsink vipe)

# RECOMMENDED EXTERNAL COMMANDS
_recommendedCommands=(git-sizer tig)

# ENVIRONMENT SETTINGS

# WORKING ENVIRONMENT
_studioDirName=studiodev
_studioDir="$(dirname ~/.)/${_studioDirName}"
# GERM lives inside studio (into which it is designed to publish)
_germDirName=germ
_germDir="${_studioDir}/${_germDirName}"
_germGitDisk="${_germDir}/.gitdisk"
_logFile="${_germDir}/germ.log"
# SET GIT COMMANDS for convenience and consistency
#_git="git --git-dir=${_germGitDisk} --work-tree=${_germDir}"
_git="git --git-dir=${_germGitDisk}"

# other important things
self=$(basename $0)
# check if a logfile exists
[[ -f "${_logFile}" ]] && _canLog=true

# USER NAME
# the git username and email are used to create a short hash which identifies
# the user in the namespace.  it is set as a global variable and used in various
# places.  it can be overridden here.
# see _setUserUUID and _uuidGet
_user=

# BEHAVIOR

# TODO figure out a better means of knowing
# 1. is this an interactive shell session
# 2. is this part of a pipe
# 3. are we in our custom interactive shell (and does that matter?)
# set up logging and stdout stderr etc with traps
# possibly check for tty?
#[[ -t 1 ]] && echo 'STDOUT is attached to TTY'
#[[ -p /dev/stdout ]] && echo 'STDOUT is attached to a pipe'
#[[ ! -t 1 && ! -p /dev/stdout ]] && echo 'STDOUT is attached to a redirection'

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses normal output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=false

# OUTPUT

# some color
red=$(tput setab 1; tput setaf 7)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)
prompt=$(tput setab 5; tput setaf 7)

user=$(tput setab 6; tput setaf 7)
_prompt() {
	# hack to avoid fixing _log and include a PROMPT type
	# TODO: add this idea into _log to keep the "universal" claim
	echo -n "${user}USER${reset} ${1} "
}

info=$(tput setab 2; tput setaf 0)
_info() {
	# hack to display info...need to fix up the whole _log idea
	echo -e "${info}INFO${reset} ${1} "
}

warn=$(tput setab 3; tput setaf 0)
_warn() {
	# hack to display warning...need to fix up the whole _log idea
	echo -e "${warn}WARN${reset} ${1} "
}

# LOGGING 

# 
# TODO also capture the git errors...this is being lost now
# and set -x is the only means of capturing the break
_log() {
	# overly complex global prompt and logging function
	# consults _DEBUG _SILENT and _LOG for behavior
	# TODO: add type for user PROMPT (ie USER interaction)
	# TODO: try and optimize...many calls for each log event (although the use
	# would never be bogged down since this is a single user system)
	# levels:
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true (and
	# there are functions (eg _format) that should never be SILENT)
	# set to 0 to force all logs into DEBUG pipeline
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	# TODO: fix this...not using it as designed
	declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	local _level=${_i[${_logLevel}]}
	local _color=${_c[${_logLevel}]}
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog:-false} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	# BUG HERE
	# if SILENT is true and _log = 4, then we don't exit as expected on FATAL
	# error
	if [ ${_SILENT} = true ] && [ ${_logLevel} = 4 ]; then
		exit 1
	elif [ ${_SILENT} = true ]; then
		return
	fi
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: $self: ${_logMessage}" && exit 1
	fi
}

# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database

for command specific usage, eg:
$ germ help add

EOF
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git repo, keeping
minimal metadata and organizing with tree objects

EOF
}

_printShellUsage() {
	cat << EOF

 add        add a new germ entry
 list       list the tag catalog
 status     show germ health
 stop       exit studio
 help       print this message

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				_germDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_germDir="$(dirname ~/.)/studio/${_germDirName}"
				_logFile="${_germDir}/germ.log"
				_log 0 "${FUNCNAME[0]}: using alternative germ dir $_germDir"
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			status)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			recover)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			sizer)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			source)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			test)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			*)
				_log 3 "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_isEnvSufficient() {
	# check for required tools, report accordingly
	# TODO add recommended checks with _missing{0:name,1:name}
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		else
			_log 0 "${FUNCNAME}: ${_required} found"
		fi
	done
	# check for germ dir (unless we are running create...this could use some
	# cleaning for clarification)
	# if there is no germ dir and this
	if [ ! -d "${_germDir}" ]; then
		#[ -z "${_subCommand:-}" ] && { _log 3 "run create first" ; return 1 }
		if [ -z "${_subCommand:-}" ]; then
			_log 3 "found no ${_germDir}; run 'germ create' first"
		 	return 1
		elif [ ! ${_subCommand:=} = "create" ]; then
			_log 3 "found no ${_germDir}; run 'germ create' first"
			_sufficient=false
		fi
	fi
	# TODO this little construct isn't correct:
	[ ${_sufficient} = true ] && return 0 || return 1
}

# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS

_getAddOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":i" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_log 0 "enabled inline mode"
				_inline=true
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	
# SUB COMMANDS


_showStatus() {
	# arg 1 = level [optional]
	# 0 = brief [default]
	# 1 = verbose
	local _level=${1:-0}
	_log 1 "$(${_git} --version)"
	_log 1 "studio name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 1 "germ user uuid: ${_user}"
	_log 1 "germ user: $(_printBlob ${_user})"
	_log 0 "'git count-objects --human'"
	_objectCount=$(${_git} count-objects --human)
	_log 1 "germ object count: ${_objectCount}"
	_lastCommit=$(${_git} rev-parse HEAD)
	_log 1 "last commit: ${_lastCommit}"
	_lastDate=$(${_git} --no-pager log -1 --format="%ad (%ah)")
	_log 1 "date of last commit: ${_lastDate}"
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
}

_status() {
	_log 1 "git version: $(${_git} --version)"
	_log 1 "studio dir name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 1 "germ user uuid: ${_userUUID}"
	_log 1 "germ current source: ${_currentSource}"
	${_git} commit-graph verify
	[ $? = 0 ] || _log 3 "'git commit-graph verify' returned an error"
	_log 1 "'git rev-parse --show-object-format HEAD'"
	${_git} rev-parse --show-object-format HEAD
	_log 1 "'git ls-tree -r HEAD' (ie what is in the last commit):"
	${_git} ls-tree -r HEAD
	_log 1 "'git ls-files --stage' (ie what is in the index):"
	${_git} ls-files --stage
	_log 1 "'git count-objects --human'"
	${_git} count-objects --human
	_log 1 "count all git objects:"
	_log 0 "'git cat-file --batch-all-objects --batch-check | wc -l'"
	${_git} cat-file --batch-all-objects --batch-check | wc -l
	_log 1 "how many total objects:"
	_log 0 "'find ${_germGitDisk}/objects -type f | wc -l':" 
	find ${_germGitDisk}/objects -type f | wc -l
	_log 1 "git cat-file -p main^{tree}' (ie show tree namespace):"
	${_git} cat-file -p main^{tree}
	#_log 1 "'git fsck --full --verbose'"
	#${_git} fsck --full --verbose
	_log 1 "'git fsck --full'"
	_gitfsck=$(${_git} fsck --full)
	_gitFsckExit=$?
	while IFS= read -r line; do
		if [[ $line =~ ^dangling ]]; then
			echo "${yellow}$line${reset}"
		fi
	done <<< "${_gitfsck}"
	_log 1 "git fsck exit status: '${_gitFsckExit}'"
	_gitDiff="${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(${_git} rev-parse HEAD)
	_inconsistentCount=$(${_gitDiff} | wc -l)
	_log 1 "last commit id: ${_lastCommit}"
	_log 1 "inconsistent count: ${_inconsistentCount}"
	if [[ ${_inconsistentCount} -ne 0 ]]; then
		_log 2 "'git diff --cached --summary HEAD' results:"
		${_git} --no-pager diff --cached --summary HEAD
	fi
	_isIndexClean || _log 3 "INDEX IS INCONSISTENT"
}


# TODO log output formatting
#${_git} log --graph --reflog
# the above runs into a pager and is quite nice and useful already
# the below is someone else's custom formatting
# $ git config --global alias.graph \
#  "log --graph --all --format='%h %s%n        (%an, %ar)%d' --abbrev-commit"

_list() {
	# HACKED now
	_log 1 "git 'ls-tree -r HEAD'"
	${_git} ls-tree -r HEAD 
}

_listTags() {
	${_git} ls-files t/*/count.*
}

_listKeys() {
	${_git} ls-files a/
} 

_mapTags() {
	# arg 1 = blobID
	# check for tags (hash at first character of line)
	# assumes global _blobArray
	[ $# -ne 1 ] && return 1
	local _blobID=${1}
	local _line
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			_log 0 "blank line detected..skipping"
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			_log 0 "^# detected, checking for tag"
			_tag=${_line%% *}
			if [ -z "${_tag:1}" ]; then
				_log 0 "empty tag, skipping"
			else
 				_log 0 "found tag '${_tag:1}'"
				# get the t/TAG/count.NUMBER
				_tagCount=$(${_git} ls-files t/${_tag:1}/count.* | cut -f3 -d/)
				_log 0 "tag count for ${_tag:1} is ${_tagCount}"
				if [ -z "${_tagCount}" ]; then
					_log 0 "first encounter with ${_tag:1}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/count.1"
					_log 0 "added count.1 in t/${_tag:1}"
				else
					_log 1 "found ${_tagCount#*.} tags for ${_tag:1}"
					${_git} --work-tree=${_germDir} update-index --remove "t/${_tag:1}/${_tagCount}"
					_log 0 "removed ${_tagCount} from index at t/${_tag:1}/${_tagCount}"
					x=${_tagCount#*.}
					((x++))
					_tagCount=count.$x
					_log 0 "set ${_tagCount}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/${_tagCount}"
					_log 0 "updated t/${_tag:1} to ${_tagCount}"
				fi
				# update the tag-path
				_path="t/${_tag:1}/$_blobID/self"
				${_git} update-index --add --cacheinfo 10064,$_emptyBlob,$_path
				_log 0 "mapped ${_blobID:0:5} in ${_path}"
			fi
		fi
	done
}

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	# TODO: consider what to do with tags
	local _maxLength=75
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	[ -z "${_commitMsgString}" ] && return 1
	echo "${_commitMsgString}"
}

_add() {
	local _germString=
	local _commitMsgString=
	local _primaryKey=
	if [ ${_inline:-null} = "true" ]; then
		_log 0 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 3 "${FUNCNAME}: 'add -i' cannot contain an empty message"
		_germString="${_workingParams}"
	else
		_message=$(vipe)
		_workingParams="${_message}"
		_germString="${_message}"
	fi
	_commitMsgString=$(_buildCommitMsg "${_germString}") || _log 4 "empty commit msg"
	_log 0 "commit message: ${_commitMsgString}"
	# set up primary key namespace mapping
	_primaryKey=$(_getNewKey) || _log 4 "could not get a new unique key"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_germString}")
	_log 1 "added the blob to the object store"
	_readBlob $_blobID 
	# map blob to primary key in a/
	_mapBlob ${_blobID} ${_primaryKey}
	_mapTags $_blobID
	_doCommit "${_commitMsgString}"
}

_create() {
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_prompt "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z ${_studioName} ] || _studioDirName="${_studioName}"
	_prompt "enter studio path ["${_studioDir}"] "
	read _studioPath
	[ -z ${_studioPath} ] || _studioDir="${_studioPath}"
	_prompt "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	_prompt "enter germ gitdisk name ["${_germGitDisk}"] "
	read _germGit
	[ -z ${_germGit} ] || _germGitDisk="${_germGit}"
	_prompt "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_prompt "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_log 0 "studio dir name: ${_studioDirName}"
	_log 0 "studio path: ${_studioDir}"
	_log 0 "germ path: ${_germDir}"
	_log 0 "germ gitdisk: ${_germGitDisk}"
	_log 0 "germ user name: ${_userName}"
	_log 0 "germ user email: ${_userEmail}"
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk}
	else
		gitdisk create -b ${_germGitDisk}
	fi
  git config --global includeif.gitdir:"${_studioDir}".path "${_studioDir}/.gitconfig-studio"
  git config --global includeif.gitdir:"${_germGitDisk}".path "${_studioDir}/.gitconfig-studio"
	git config --file="${_studioDir}"/.gitconfig-studio user.name "${_userName}"
	git config --file="${_studioDir}"/.gitconfig-studio user.email "${_userEmail}"
	# _user is global var and short
	# _userUUID is blobid and long
	_userUUID=$(_uuidGet)
	export _user=${_userUUID:0:4}
	# map u/uuid/self to blob of git user string "user:email"
	# set /u/uuid/current as empty
	_mapBlob "${_userUUID}" "u/${_user}/self"
	_mapEmpty "u/${_user}/current"
	# add blob "germ created by jkl:jason@bloom.us (3c7c) $DATE"
	# write blob, get blobid (hash key)
	_blobID=$(_writeBlob "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)")
	# map blob to a/DATE/uuid.seconds
	_primaryKey=$(_getNewKey) || _log 4 "could not get a new unique key"
	_mapBlob ${_blobID} ${_primaryKey}
	_doCommit "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

# TIP
# git help --config
# lists all the git config variables

# TODO assess and decide what to do if (remote possibility) a 4-char hash
# collision occurs from 2 unique users.  though by using 4 characters the odds
# are 1 in 

}

_sizer() {
	cd ${_germGitDisk}
	git-sizer --verbose
}

_makeDirty() {
	# test function to intentionally leave a mess
	echo "TEST 1: PUT a blob in without a map"
	echo "TEST 2: PUT a blob, map key, forget to map tags"
	echo "TEST 3: other atomic tests?"
	echo "TODO: DETECT condition...clean and clear programatically"
}


# TODO next
# update add()
# add the user
# decide whether to put the user:email blob or use an empty /self
# put the first blob in
# make the _userUUID a global VAR we get and set
# change the a/ path to be a/YEAR/MONTH/DAY/$userUUID.$unixSeconds
#
# add some sanity checks with user management...because the possibility of a
# lost or broken git config risks breaking the whole thing if we rely on the git
# config includeif
# then build _source()
# then put data in and move this to a production state
# much of the recovery functions will have to come in time
# additionally, migrating, merging, etc will have to follow later
# need to move data in and begin testing with actual data for the next phase,
# which is to begin building out the namespace mapping and the viewing,
# browsing, searching, and editing process...including blob naming, blob
# workflows, directory lattice, and project creation



####################################
# GERM PRIMITIVES
#
# _getNewKey		generate the unique filesystem name for the blob: $uuid.$seconds 
# _uuidGet			get or generate the uuid string to identify a user
# _setUserUUID	set the global var _user

_getNewKey() {
	# generate a new unique unix_time key path using date +%s and global _user
	# make sure it is unique...wait a couple seconds...otherwise return 1
	# print the key path
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_user}.${_key}"
	i=0
	while _doesKeyExist "${_keyPath}"; do
		sleep 0.5
		((i++))
		if [[ "$i" == '3' ]]; then
			return 1
		fi
	done
	echo "${_keyPath}"
}

_uuidGet() {
	# arg 1: user:email string [optional...uses 'git config' otherwise]
	# using hash-object, generate a unique uuid
	# truncated, it serves the u/user field and the primary key as $uuid.$seconds
	# on the possibility of collision...printf "4^16 = %'d\n" $(echo "4^16" | bc)
	# WRONG...its 16^4 which is a whole lot smaller (65,536)
	local _u
	local _e
	local userstring
	local uuid
	if [[ -z "${1:-}" ]]; then
		_u=$(${_git} config --get user.name)
		_e=$(${_git} config --get user.email)
		userstring="${_u}:${_e}"
	else
		userstring="${1}"
	fi
	uuid=$(echo "${userstring}" | ${_git} hash-object -w --stdin)
	echo ${uuid}
}

_setUserUUID() {
	# set the global var used in file mapping (if it is empty)
	if [ -z ${_user} ]; then
		# if running create...just leave it empty (it will get set in _create()
		[ "${_subCommand:-}" = create ] && return 0
		# otherwise, set the global var
		_userUUID=$(_uuidGet)
		export _user=${_userUUID:0:4}
	fi
}

######################################
# GIT PRIMITIVES
#
# generic git interface functions we use
# _writeBlob			write a blob...return a blobID
#	_readBlob				read a blob into a bash array and export as global var
# _printBlob			print the contents of a blob to stdout
# _mapBlob				add an entry in the index pointing to the blobID
# _mapEmpty				write an empty blob as a key to a path (eg u/$uuid/current)
# _doCommit				commit changes to the repo
# _doesKeyExist		check for an existing key in namespace (eg t/$tag/catalog/x)
# _isIndexClean		check the integrity and state of blobs and maps
# TODO separate _writeBlob and _putBlob?
# _writeBlob should add a key
# _putBlob should only put a blob in and return the blobID

_writeBlob() {
	# arg 1 = blob
	# return blobID
	local blobID
	[ -z "${1:-}" ] && return 1
	blobID=$(${_git} hash-object --stdin -w <<< "${1}")
	echo "${blobID}"
	# TODO improve this to avoid errors
	# catch non-zero exit of hash-object and return that value
}

_readBlob() {
	# arg 1 = blob ID
	# read a blob into a bash array
	# export the array into the global environment for further use
	local _blobID=$1
	${_git} cat-file -e ${_blobID} &>/dev/null || return 1
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	if [ ${#_blobArray[@]} -ne 0 ]; then
		_log 1 "read blob ${_blobID:0:5}"
		_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
		export _blobArray
	else
		_log 3 "${_blobID} is empty"
		return 1
	fi
}

_printBlob() {
	# arg 1 = blob ID
	# print the contents of the blob to stdout
	${_git} cat-file -p ${1} || return 1
}

_mapBlob() {
	# arg 1 = blobID (full sha)
	# arg 2 = path
	[[ -z "${1:-}" || -z "${2:-}" ]] && return 1
	_log 0 "${FUNCNAME}: git update-index --add --cacheinfo 10064,${1},${2}"
	${_git} update-index --add --cacheinfo 10064,"${1}","${2}"
}

_mapEmpty() {
	# arg 1 = path
	[ -z "${1:-}" ] && return 1
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	_log 0 "${FUNCNAME}: git update-index --add --cacheinfo 10064,${_emptyBlob},${1}"
	${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"${1}"
}

_doCommit() {
	# discrete operation...write the index as a commit
	_log 0 "commit msg: '${1}'"
	_commitMsg="${1}"
	_tree=$(${_git} write-tree)
	_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
		_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_commitMsg")
	else
		_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_commitMsg}")
	fi
	_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	_log 1 "updated the HEAD reference"
	return 0
}	

_doesKeyExist() {
	# arg 1 = key (namespace path)
	# return 0 if true
	# return 1 if false (no key exists)
	${_git} ls-files --error-unmatch "${1}" &>/dev/null || return 1
}

_isIndexClean() {
	# arg 1 = level (0-3) [optional...0 is default]
	# 0 normal...just check the basics and return 0/1
	# 1 deep...run the full checks
	# to override the global...set the first var
	local _inspectLevelOverride=
	local _inspectLevel=${_inspectLevelOverride:-${1:-0}}
	local _levelMap=([0]=QUICK [1]=THOROUGH [2]=DEEP)
	local _level=${_levelMap[${_inspectLevel}]}
	if [ $_level = "QUICK" ]; then
		_log 0 "${FUNCNAME}: running index inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
		return $?
	elif [ $_level = "THOROUGH" ]; then
		_log 0 "${FUNCNAME}: running index inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --cached HEAD || return 1
		_log 0 "'git fsck --full --verbose'"
		${_git} fsck --full --verbose
		_gitFsckExit=$?
		_log 1 "git fsck exit status: '${_gitFsckExit}'"
	elif [ $_level = "DEEP" ]; then
		_log 0 "${FUNCNAME}: ${_inspectLevel}: ${_level} not implemented yet"
		return 1
	else
		_log 3 "${FUNCNAME}: illegal level $_level"
		return 1
	fi
}


################
# SOURCE
################

_getSource() {
	# print the current SOURCE
	# read c/VALUE/current
	${_git} ls-files c/*/current | cut -f2 -d/
}

_isSourceSet() {
	# no args
	# check for c/*/current
	# return 0 if true
	# return 1 if false
	_doesKeyExist c/*/current
}

_isSourceNew() {
	# arg 1 = new source name
	# checks for c/$1/self
	# if it exists, return 1 (no it is not new)
	# if it does not exist, return 0 (yes it is new)
	! _doesKeyExist "c/${1}/self"
}

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	_isSourceSet && _deleteKey "c/*/current"
	_mapEmpty "c/${1}/current"	
}

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	_id=$(_writeBlob "${1}")
	_mapBlob "${_id}" "c/${1}/self"
	_desc=$(_writeBlob "${2}")
	_mapBlob "${_desc}" "c/${1}/self.description"
}

# germ methods required
# _getKeyValue (boolean)
# _deleteKey
# _readKey
# _listKeys
# _updateKey
#
# germ Bkey is a boolean or binary flag which indicates something
# it is exclusive in its namespace...ie c/*/NAMESPACE can only contain one Bkey
# its first use is with indicating the current user u/$UUID/current
# it also is used to indicate the current notebook source with c/$SOURCE/current
# it uses _mapEmpty to map an empty blob
# it refers to its parent directory in the namespace
# METHODS USED
# _doesKeyExist		(git)
# _deleteBkey			(germ bkey)
# _insertBkey			(germ bkey)
# _getBkeyValue		(germ bkey)
#
# germ Key is used similarly except that it contains information beyond an
# exclusive boolean setting
# ex. u/$UUID/self points to a blob from which the $UUID is derived, the string
# contianing the "user name:user email" used by git
# the information in the blob to which self points is arbitrarily defined by the
# use...u/*/self --> "user name:user email"
# c/*/self --> "source name"
# additionally, a key can contain additional attributes, eg c/*/self.description
# which contains the user-supplied description of the source
# the self key is used to enforce uniqueness and map into namespace the
# truncated hash
#
# PROBLEM I MUST ADDRESS...using the truncated HASH introduces a BUG...in that
# there is a remote possibility that 2 unique "keys" (2 different user:email
# strings eg which produce a hash whose first x characters happen to collide)
# ie...using the truncated hash in the namespace defeats the purpose.  USE the
# name in the namespace
# JUST DONT DO IT...
#
# METHODS USED
# _doesKeyExist
# _readKey
# _listKeyAttributes
# _updateKey

_getKeyValue() {
	# arg 1 = key eg c/*/current
	# prints value from c/$value/$key
	${_git} ls-files "${1}" | cut -f2 -d/
}

_deleteKey() {
	# arg 1 = key
	${_git} --work-tree=${_germDir} rm --cached --quiet "${1}"
	# THIS SHOULD be made more discrete
	# this REMOVES all keys!!!
}

_readKey() {
	# given key, eg c/$source/self.description
	# get the blob id
	# print the blob
	local _blobid
	_blobid=$(${_git} ls-files --stage ${1} | cut -d' ' -f2)
	_printBlob ${_blobid} 
}

_getSourceList() {
	# create a list from c/*/self
	${_git} ls-files --stage c/*/self | cut -f2 -d/
}

# source methods
# _isSourceSet		check for c/*/current
# _getSource			return c/$source/current
# _setSource			remove c/*/current (if set) and add c/$source/current 
# _addSource			user dialog to add new and (optionally) set current
#
# source name: eg lgb-12Jan2023
# source description: arbitrary text describing source

_test() {
	# place to test various things
	_isSourceSet && echo "source is set...next get source"
	_isSourceSet || echo "source is NOT set...report as UNSET"
	_setSource "one"
	_getSource
	_setSource "two"
	_getSource
	_setSource "three"
	_getSource
	_isSourceNew "three" || echo "SOURCE three is not new"
	_isSourceNew "three" && echo "SOURCE three is new"
	_isSourceNew "ree" || echo "SOURCE ree is not new"
	_isSourceNew "ree" && echo "SOURCE ree is new"
	_saveSource "three" "three is the nuber of the day"
	_isSourceNew "three" || echo "SOURCE three is not new"
	_isSourceNew "three" && echo "SOURCE three is new"
	_isSourceNew "ree" || echo "SOURCE ree is not new"
	_isSourceNew "ree" && echo "SOURCE ree is new"
}


###############
###### SOURCE
###############

_source () {
	local _currentSource="UNSET"
	local _maxLength=20
	if [[ -z "${1:-}" ]]; then
		_info "use 'source' to add and manage media source list"
	#	_info "use 'source' to add and manage media source list"
	#	_info "eg, naming notebooks, sets of papers, etc"
	#	_info "a notebook name is used as a virtual category"
	fi
	# check if source is set already
	if _isSourceSet; then
		_currentSource=$(_getSource)
	fi
	trap _irishExit SIGINT
	_mainMenu() {
	echo -ne "
    SOURCE currently set to ${green}${_currentSource}${reset}
    c) change source
    s) show details of ${_currentSource}
    n) add a new media source
    e) exit

"
	while read -r -s -n 1 -p "${prompt}USER${reset} enter selection " _selection; do
		case $_selection in
 			c)
				_setSource $(_getSourceList | fzf)
				echo
				exit 0
				;;
			s)
				echo
				_info "current source: ${_currentSource}"
				_info "description:    $(_readKey c/${_currentSource}/self.description)"
				;;
			n)
				echo
				_newSourceMenu
				;;
			e|q)
				echo
				exit 0
				;;
			h|\?)
				echo
				_info "use 'source' to add and manage media source list"
				_info "eg, naming notebooks, sets of papers, etc"
				_info "a notebook name is used as a virtual category"
				;;
			*)
				echo
				[[ -z ${_a:-} ]] && continue 
				_warn "wrong selection [${_selection}]; try again"
				;;
			esac
		done
	}
	_newSourceMenu() {
			while read -r -e -n${_maxLength} -p "${prompt}USER${reset} enter new source name (? for guidance): " _a; do
				[[ ${#_a} -eq 20 ]] && _warn "reached max length of ${_maxLength}!"
				case "${_a}" in
					help|h|\?)
						_info "enter the name of the source material"
						_info "example: lgb-12-jan-23"
						_info "example: bible"
						_info "example: plato-apology"
						_info "example: random"
						_info "rules: a-z A-Z 0-9 - allowed"
						_info "rules: max length ${_maxLength} characters, min is 3"
						_info "this name is used to identify a 'source' ie notebook, etc"
						;;
					quit|q)
						_info "try again later"
						_mainMenu
						;;
					*)
						if [[ "${_a}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){3,20}$ ]]; then
							if _isSourceNew "${_a}"; then
								_info "${_a} is new and acceptable"
							else
								_warn "${_a} is not new"
								continue
							fi
							break
						else
							_warn "'${_a}' is not allowed, try again"
							_warn "rules: a-z A-Z 0-9 - allowed"
							_warn "rules: max length ${_maxLength} characters, min is 3"
						fi
						;;
				esac
			done
			while read -r -e -p "${prompt}USER${reset} enter description for ${_a}: " _b; do
				case "${_b}" in
					help|h|\?)
						_info "enter the description for the source ${_a}"
						_info "example: little green notebook 12 Jan 2023" 
						_info "example: lecture notes from chem 202"
						;;
					quit|q)
						_warn "try again later"
						_mainMenu
						;;
					*)
						break
						;;
				esac
			done
			echo "source name: ${_a}"
			echo "source description: ${_b}"
			while read -r -e -n1 -p "${prompt}USER${reset} save ${_a} as new notebook? (y/n) " _c; do
				case ${_c} in
					y)
						_saveSource "${_a}" "${_b}"
						break
						;;
					n)
						exit 0
						;;
					*)
						continue
						;;
				esac
			done
			while read -r -e -n1 -p "${prompt}USER${reset} set ${_a} as current? (y/n) " _d; do
				case ${_d} in
					y)
						_setSource "${_a}"
						exit 0
						;;
					n)
					exit 0	
						;;
					*)
						continue
						;;
				esac
		done
}
	_mainMenu
}

###############
###### SHELL
###############

# TODO add trap to commit changes when shell exits (ie commit a session)

_shell() {
	# enter (cd) into studio environment
	# change the command history file
	# change the prompt dynamically
	cd "${_studioDir}" || _log 4 "can not enter studio"
	HISTFILE="${_studioDir}/.germ_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _prompt=
	local _dirty=
	# embedded prompt function setting...to catch a dirty index for now
	_setPrompt() {
		local _dirty=""
		_isIndexClean || _dirty="${boldred}X${reset}"
		_cs=$(_getSource)
			_prompt="${prompt}${_studioDirName}${reset}:${label}${_germDirName}${reset} ${green}${_user}${reset} [${_cs}] ${_dirty} > "
	}
	_setPrompt
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

germ: type ${green}help${reset} for guidance
      type ${red}stop${reset} to leave

HEREDOC

	local __input
	while IFS='' read -r -e -d $'\n' -p "${_prompt}" __input; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			cd $OLDPWD; exit 0
		elif [[ "${__input}" =~ (^help$|^h$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_listTags
		elif [[ "${__input}" =~ (^status$|^stat$) ]]; then
			_showStatus
			_isIndexClean || _log 3 "DIRTY INDEX"
		elif [[ "${__input}" =~ (^add$|^a$) ]]; then
			eval "${self}" add || true
		else
			eval "${self}" "${__input}" || :
		fi
		_setPrompt
	done
}	

###########################
# trap and signal catching

_irishExit() {
  echo -ne "\r${yellow}WARNING${reset}: ctrl-c detected; to resume, press R, to quit, press ENTER\n"
  read -s -t 15 -n 1 _ANS
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
  else
    _log 4 "user requested exit with ctrl-c"
  fi
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
	_log 0 "${FUNCNAME[0]}: _subCommand: ${_subCommand:-}"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# validate the environment first
	_isEnvSufficient || _log 4 "cannot run until these problems are resolved"
	# set the global user
	_setUserUUID || _log 4 "cannot set the user hash string"
	# get and set the current source notebook
	_currentSource=$(_getSource) 
	# run germ shell if no arguments
	# TODO figure out how to pipe input to germ without triggering the shell
	[ -z "${_subCommand:-}" ] && _shell
	# otherwise, pass the commands to the called "command"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

