#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# SCRIPT AND SHELL SETTINGS
set -o errexit
set -o nounset
set -o pipefail

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(git gitdisk dsink tig vipe)

# ENVIRONMENT SETTINGS

# WORKING ENVIRONMENT
_studioDirName=studiodev
_studioDir="$(dirname ~/.)/${_studioDirName}"
# GERM lives inside studio (into which it is designed to publish)
_germDirName=germ
_germDir="${_studioDir}/${_germDirName}"
_germGitDisk="${_germDir}/.gitdisk"
_logFile="${_germDir}/germ.log"
# SET GIT COMMANDS for convenience and consistency
#_git="git --git-dir=${_germGitDisk} --work-tree=${_germDir}"
_git="git --git-dir=${_germGitDisk}"

# other important things
self=$(basename $0)
# check if a logfile exists
[[ -f "${_logFile}" ]] && _canLog=true

# BEHAVIOR

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses normal output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=false

# OUTPUT

# some color
red=$(tput setaf 1)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
prompt=$(tput setab 5; tput setaf 7)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)

_prompt() {
	# hack to avoid fixing _log and include a PROMPT type
	# TODO: add this idea into _log to keep the "universal" claim
	echo -n "${prompt}USER${reset}: ${1} "
}

# LOGGING 

_log() {
	# overly complex global prompt and logging function
	# consults _DEBUG _SILENT and _LOG for behavior
	# TODO: add type for user PROMPT (ie USER interaction)
	# TODO: try and optimize...many calls for each log event (although the use
	# would never be bogged down since this is a single user system)
	# levels:
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true (and
	# there are functions (eg _format) that should never be SILENT)
	# set to 0 to force all logs into DEBUG pipeline
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	# TODO: fix this...not using it as designed
	declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	local _level=${_i[${_logLevel}]}
	local _color=${_c[${_logLevel}]}
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog:-false} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	# BUG HERE
	# if SILENT is true and _log = 4, then we don't exit as expected on FATAL
	# error
	if [ ${_SILENT} = true ] && [ ${_logLevel} = 4 ]; then
		exit 1
	elif [ ${_SILENT} = true ]; then
		return
	fi
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: $self: ${_logMessage}" && exit 1
	fi
}


# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database

for command specific usage, eg:
$ germ help add

EOF
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git repo, keeping
minimal metadata and organizing with tree objects

EOF
}

_printShellUsage() {
	cat << EOF

 add        add a new germ entry
 list       list the tag catalog
 status     show germ health
 stop       exit studio
 help       print this message

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				_germDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_germDir="$(dirname ~/.)/studio/${_germDirName}"
				_logFile="${_germDir}/germ.log"
				_log 0 "${FUNCNAME[0]}: using alternative germ dir $_germDir"
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			status)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			recover)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			*)
				_log 3 "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}	

_isEnvSufficient() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		fi
	done
	# check for germ dir (unless we are running create...this could use some
	# cleaning for clarification)
	if [ ! -d "${_germDir}" ] && [ ! ${_subCommand} = "create" ]; then
		_log 3 "found no ${_germDir}; run 'germ create' first"
		_sufficient=false
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}

# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
_getAddOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":i" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_log 0 "enabled inline mode"
				_inline=true
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	
# germ add
# two options
#		inline (invoked by add -i)
#			no tags allowed, naturally (bash interprets # as a comment)
#			tags allowed if escaped ("add -i \#<tag> followed by the entry")
#		buffer (add without args, calls an editor, the saved results comprise)
#			
# SUB COMMANDS

__list() {
	#local _gitdir="${_germGitDisk}"
	#local _git="git --git-dir=${_gitdir}"
  { ${_git} rev-list --objects --all
  ${_git} rev-list --objects -g --no-walk --all
  ${_git} rev-list --objects --no-walk \
        $(${_git} fsck --unreachable |
          grep '^unreachable commit' |
          cut -d' ' -f3)
}
}

_showStatus() {
	# arg 1 = level [optional]
	# 0 = brief [default]
	# 1 = verbose
	local _level=${1:-0}
	_log 1 "$(${_git} --version)"
	_log 1 "studio dir name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 0 "'git count-objects --human'"
	_objectCount=$(${_git} count-objects --human)
	_log 1 "germ object count: ${_objectCount}"
	_lastCommit=$(${_git} rev-parse HEAD)
	_log 1 "last commit: ${_lastCommit}"
	_lastDate=$(${_git} --no-pager log -1 --format="%ad (%ah)")
	_log 1 "date of last commit: ${_lastDate}"
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
}
	



_status() {
	_log 1 "git version: $(${_git} --version)"
	_log 1 "studio dir name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	${_git} commit-graph verify
	[ $? = 0 ] || _log 3 "'git commit-graph verify' returned an error"
	_log 1 "'git rev-parse --show-object-format HEAD'"
	${_git} rev-parse --show-object-format HEAD
	_log 1 "'git ls-tree -r HEAD' (ie what is in the last commit):"
	${_git} ls-tree -r HEAD
	_log 1 "'git ls-files --stage' (ie what is in the index):"
	${_git} ls-files --stage
	_log 1 "'git count-objects --human'"
	${_git} count-objects --human
	_log 1 "count all git objects:"
	_log 0 "'git cat-file --batch-all-objects --batch-check | wc -l'"
	${_git} cat-file --batch-all-objects --batch-check | wc -l
	_log 1 "how many total objects:"
	_log 0 "'find ${_germGitDisk}/objects -type f | wc -l':" 
	find ${_germGitDisk}/objects -type f | wc -l
	_log 1 "git cat-file -p main^{tree}' (ie show tree namespace):"
	${_git} cat-file -p main^{tree}
	_log 1 "'git fsck --full --verbose'"
	#${_git} fsck --full --verbose
	${_git} fsck --full
	_gitFsckExit=$?
	_log 1 "git fsck exit status: '${_gitFsckExit}'"
	local _gitDiff="${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(${_git} rev-parse HEAD)
	_inconsistentCount=$(${_gitDiff} | wc -l)
	_lostMaps=$(${_gitDiff} | cut -f5 -d' ')
	_log 1 "last commit id: ${_lastCommit}"
	_log 1 "inconsistent count: ${_inconsistentCount}"
	_log 1 "uncommitted files: ${_lostMaps}"
	#_log 1 "'git fsck --unreachable'"
	#${_git} fsck --unreachable
	#_log 1 "'git reflog'"
	#${_git} reflog
	#_log 1 "'git log --graph --reflog'"
	#${_git} log --graph --reflog
	# the above runs into a pager and is quite nice and useful already
	# the below is someone else's custom formatting
	_isIndexClean || _log 3 "INDEX IS INCONSISTENT"
	#_readBlob bb10
	#_recover
}


# TODO log output formatting
# $ git config --global alias.graph \
#  "log --graph --all --format='%h %s%n        (%an, %ar)%d' --abbrev-commit"

_list() {
	# HACKED now
	_log 1 "git 'ls-tree -r HEAD'"
	${_git} ls-tree -r HEAD 
}

_listTags() {
	${_git} ls-files t/*/count.*
}

_listKeys() {
	${_git} ls-files a/
} 
	

# TODO
# add virtual tracking...pointers to the last file entered
#
# /j/last		-->
#
# /j
# /j/new.0	-->	a/2023/01/30/1675144729
# /j/new.1	-->	and so on...an always flowing list, always updated
#
# /j/edited.0	--> d/jkl/1675134323
# /j/edited.1	--> and so on...adjust the depth here based on speed and screen
# space and use case 
#
# can we use the index but not commit all its noise?
# use it to track changes to an add object operation
# then remove it before the commit
#
# TODO
# define the tree index namespace and its use
# a/		primary key, hash of date, unix seconds key
# b/		workflow status
# c/		source
# d/		first word catalog
# e/		tag catalog
# f/
# g/
# h/
# i/
# j/
# k/
# l/
# m/
# n/
# o/
# p/
# q/
# r/
# s/
# t/
# u/
# v/
# w/
# x/
# y/
# z/

# NAMESPACE construction
# /a/		primary namespace key
#				YEAR/MONTH/DAY/UNIX_SECONDS
#				eg 2023/01/30/1675101655
# /b/		workflow status
#					new			:	added only
#					read		: viewed at least once
#					edited	: edited at least once
#					other operations: move, rename, delete ?
# thus, after adding one, then viewing it:
# /b/add/
# /b/read/1675101655
# /b/edited/
# each blob moves through namespaces following action on the blob
#
# /c/		source (a catalog of notebooks, etc, from whence the germ came)
# /d/		first word catalog
# /e/		tag catalog
# /f/		heuristic
#					matches /d and /e keywords from text and maps them
#					matches text indicators (cf, re, eg, ie, todo, etc)
#					matches operators (<,>,=,+,*,@,$...etc) [future]

# TODO
# make writes more atomic?
# 		j/atomic/last.key
# use j/atomic/key.add
# 		j/atomic/key.map
#			j/atomic/key.tree
#			j/atomic/key.commit
# check for consistency each time

# TODO: question: define line limit or not?  bash arrays have none
# read blob
_readBlob() {
	# arg 1 = blob ID
	# read a blob into a bash array
	# export the array into the global environment
	local _blobID=$1
	${_git} cat-file -e ${_blobID} &>/dev/null || return 1
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	if [ ${#_blobArray[@]} -ne 0 ]; then
		_log 1 "read blob ${_blobID:0:5}"
		_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
		export _blobArray
	else
		_log 3 "${_blobID} is empty"
		return 1
	fi
}

######################
# INDEX MANIPULATION

_mapPrimaryKey() {
	# arg 1 = primary key
	# arg 2 = blobID
	# assumes global _blobArray
	# TODO add some sanity checks here
	local _keyPath=$1
	local _blobID=$2
	# UPDATE the index (ie maps blob to namespace...hashed date - key is seconds)
	${_git} update-index --add --cacheinfo 10064,$_blobID,${_keyPath}
	_log 1 "added ${_blobID:0:5} as ${_keyPath}"
}

_mapBlob() {
	# TODO change this function to be a blob namespace mapper
	# ie take a blobID, create the namespace path
	# eg t/<tag>/$BLOBID/[properties i can now manipulate]
	# arg 1 = path
	# arg 2 = blobID
	[ $# -eq 0 ] && return 1
	local _path="${1}"
	local _blobID=${2}
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	_log 0 "empty blob hash: $_emptyBlob"
	_path="z/${_blobID}/self"
	_log 0 "path: $_path"
	_result=$(${_git} update-index --add --cacheinfo 10064,$_emptyBlob,$_path)
	_e=$?
	_log 0 "update-index exit code and message: $_e: '$_result'"
	_log 1 "mapped ${_blobID:0:5} as ${_path}"
}

_addEmptyTree() {
	#########################################################
	local _blobID=${1}
	_log 0 "CORRUPTING FOR TESTING (adding an empty tree)"
	_emptyTree=$(${_git} mktree </dev/null)
	_emptyTreePath="y/${_blobID}"
	_et=$(echo -e 040000 tree $_emptyTree\\t$_emptyTreePath)
	_gitExit=$(echo "${_et}" | ${_git} update-index --add --index-info)
	_log 1 "git update index for empty tree result: '${_gitExit}'"
	_log 1 "the next time it runs we want _isIndexClean to ERR"
	#########################################################
}


_mapFirstLine() {
	# take first line
	# replace space with dash
	# add to f/
	echo "first line processor"
}

_mapTags() {
	# arg 1 = blobID
	# check for tags (hash at first character of line)
	# assumes global _blobArray
	[ $# -ne 1 ] && return 1
	local _blobID=${1}
	local _line
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			_log 0 "blank line detected..skipping"
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			_log 0 "^# detected, checking for tag"
			_tag=${_line%% *}
			if [ -z "${_tag:1}" ]; then
				_log 0 "empty tag, skipping"
			else
 				_log 0 "found tag '${_tag:1}'"
				# get the t/TAG/count.NUMBER
				_tagCount=$(${_git} ls-files t/${_tag:1}/count.* | cut -f3 -d/)
				_log 0 "tag count for ${_tag:1} is ${_tagCount}"
				if [ -z "${_tagCount}" ]; then
					_log 0 "first encounter with ${_tag:1}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/count.1"
					_log 0 "added count.1 in t/${_tag:1}"
				else
					_log 1 "found ${_tagCount#*.} tags for ${_tag:1}"
					${_git} --work-tree=${_germDir} update-index --remove "t/${_tag:1}/${_tagCount}"
					_log 0 "removed ${_tagCount} from index at t/${_tag:1}/${_tagCount}"
					x=${_tagCount#*.}
					((x++))
					_tagCount=count.$x
					_log 0 "set ${_tagCount}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/${_tagCount}"
					_log 0 "updated t/${_tag:1} to ${_tagCount}"
				fi
				# update the tag-path
				_path="t/${_tag:1}/$_blobID/self"
				${_git} update-index --add --cacheinfo 10064,$_emptyBlob,$_path
				_log 0 "mapped ${_blobID:0:5} in ${_path}"
			fi
		fi
	done
}

# i had a bug which opened my eyes to an interesting possibility
# i was adding the whole string (it was _workingParams or _message) as the
# commit message...which made git log and tig both show the germ itself nicely.
# i fixed the commit to use the first line instead of the whole message string
# and now the git log and tig both lost the bug.


# commit relies on _blobArray, using the first line as the commit msg
_doCommit() {
	# discrete operation...write the index as a commit
	_log 0 "commit msg: '${1}'"
	_commitMsg="${1}"
	_tree=$(${_git} write-tree)
	######### stderr: warning: index entry is a directory, but not sparse (00000000)
	###  BUG HERE: when we have an empty tree...we should catch it here if we can
	################ this results in an inconsistent index
	_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
		_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_commitMsg")
	else
		_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_commitMsg}")
	fi
	_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	_log 1 "updated the HEAD reference"
	return 0
}	

# TODO add()
# the namespace is important.  namespace is created and modified every write.
# expensive, but we get a lot in exchange.  we use the object hash id as leafs
# in the namespace, as properties.
# so the namespace is not a tree as much as a lattice
# each object has a history.
# 1. create an object
# 2. add primary key...get blobID
# 3. map primary key namespace
# 4. map hueristic namespace
# >> call the germ and edit...add instructions
# each read of the file puts it through the mapping filter
# the mapping filter evaluates the file, consults with the existing index, then
# modifies the index based on the data, (never the file).
# the ability to restore the index is important...which is to pull the last
# commit tree and use it when there is a question...perhaps stash the objects
# and the dirty commits...and offer restore options.  the index is composed of
# 26 namespace slots, a-z.  each namespace [a-z] is used for classification, eg
# as follows
#
# define the tree index namespace and its use
# a/		primary key, hash of date, unix seconds key
# b/		workflow status
# c/		source
# d/		first word catalog
# e/
# f/		first word
# g/
# h/
# i/
# j/
# k/
# l/		first line
# m/
# n/
# o/
# p/
# q/
# r/
# s/		source (notebook name, free, other)
# t/		tag (human produced)
# u/		user actions
# v/
# w/
# x/
# y/
# z/
#
# each write must then collect trees which each are attached to the various
# namespace slots for the blob in question
# eg
# i put in a germ, it gets slotted in t/germ/f65h7d
# i look at it later by selecting t/germ from the list on the screen
#    the screen is colored by heat and select simple options
# i can edit a file for one
# i can also act on the file
# these both interact with the namespace tree
# i would select from the list (eg) based on commit message
# commit message must therefore be better curated
# they must be no longer than 60 characters (eg)
# they will be constructed from the first string of words in the germ
# they will be normalized (?)
# the object edited will be the blobID
# every read and edit of every blob results in:
#		capture the tree of the name of the blobID (a snapshot of the blob "state")
#		attach the tree to the next first location it gets put
#		link the others
# 	u/ for user actions
#		f/ for blob flow
#		 

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	# TODO: consider what to do with tags
	local _maxLength=75
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	#
	##################### BUG
	#_log 0 "${FUNCNAME}: found ${_lines} lines in string"
	# ############## when i have _log on...and pass a value from the function
	# _log fucks it up
	#####################
	# if single line string, truncate if necessary and return
	#if [ ${_lines} = 1 ]; then
	#	_commitMsgString="${1:0:${_maxLength}}..."
		#_log 0 "${FUNCNAME}: commit message string: '${_commitMsgString}'"
	#	echo "${_commitMsgString}"
	#	return
	#fi
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		#echo reading line: "$line"
		words=($line)
		#echo words in line: ${#words[@]}
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			#echo " one word line: '${line%% *}'"
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				#echo "  empty commit msg string"
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				#echo "  non-empty commit msg string"
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			#echo " ignore empty line: '${line}'"
			true
		# multi-word lines
		else
			#echo " multi-line line: '${line}'"
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		#echo " inside loop commit string: '${_commitMsgString}'"
		#echo " string length: ${#_commitMsgString}"
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	[ -z "${_commitMsgString}" ] && return 1
	echo "${_commitMsgString}"
	#echo "outside loop commit string: '${_commitMsgString}'"
}

_doesKeyExist() {
	# arg 1 = key (namespace path)
	# return 0 if true
	# return 1 if false (no key exists)
	${_git} ls-files --error-unmatch "${1}" &>/dev/null || return 1
}

_getNewKey() {
	# generate a new unique unix_time key path using date +%s
	# make sure it is unique...wait a couple seconds...otherwise return 1
	# print the key path
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_key}"
	i=0
	while _doesKeyExist "${_keyPath}"; do
		sleep 0.5
		((i++))
		if [[ "$i" == '3' ]]; then
			return 1
		fi
	done
	echo "${_keyPath}"
}

_add() {
	local _germString=
	local _commitMsgString=
	local _primaryKey=
	if [ ${_inline:-null} = "true" ]; then
		_log 0 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 4 "${FUNCNAME}: 'add -i' cannot contain an empty message"
		_germString="${_workingParams}"
	else
		_message=$(vipe)
		#_log 0 "vipe-produced entry: $_message"
		_workingParams="${_message}"
		_germString="${_message}"
	fi
	_commitMsgString=$(_buildCommitMsg "${_germString}") || _log 4 "empty commit msg"
	_log 0 "commit message: ${_commitMsgString}"
	# set up primary key namespace mapping
	_primaryKey=$(_getNewKey) || _log 4 "could not get a new unique key"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_germString}")
	_log 1 "added the blob to the object store"
	_readBlob $_blobID 
	_mapPrimaryKey $_primaryKey $_blobID || _log 4 "ERROR: _mapPrimaryKey $_primaryKey $_blobID"
	_mapTags $_blobID
	_doCommit "${_commitMsgString}"
}

# git ls-files is the correct way to navigate the git tree we are creating here

# TODO make an empty initial commit now and remove the check for parent
_create() {
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_prompt "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z ${_studioName} ] || _studioDirName="${_studioName}"
	_prompt "enter studio path ["${_studioDir}"] "
	read _studioPath
	[ -z ${_studioPath} ] || _studioDir="${_studioPath}"
	_prompt "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	_prompt "enter germ gitdisk name ["${_germGitDisk}"] "
	read _germGit
	[ -z ${_germGit} ] || _germGitDisk="${_germGit}"
	_prompt "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_prompt "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_log 0 "studio dir name: ${_studioDirName}"
	_log 0 "studio path: ${_studioDir}"
	_log 0 "germ path: ${_germDir}"
	_log 0 "germ gitdisk: ${_germGitDisk}"
	_log 0 "germ user name: ${_userName}"
	_log 0 "germ user email: ${_userEmail}"
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk}
	else
		gitdisk create -b ${_germGitDisk}
	fi
  git config --global includeif.gitdir:"${_studioDir}".path "${_studioDir}/.gitconfig-studio"
  git config --global includeif.gitdir:"${_germGitDisk}".path "${_studioDir}/.gitconfig-studio"
	git config --file="${_studioDir}"/.gitconfig-studio user.name "${_userName}"
	git config --file="${_studioDir}"/.gitconfig-studio user.email "${_userEmail}"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

# TIP
# git help --config
# lists all the git config variables

}

_isIndexClean() {
	# arg 1 = level (0-3) [optional...0 is default]
	# this function needs to run in 2 ways
	# 1 normal...just check the basics
	# 2 thorough...run the full checks
	# to override the global...set the first var
	local _inspectLevelOverride=
	local _inspectLevel=${_inspectLevelOverride:-${1:-0}}
	local _levelMap=([0]=QUICK [1]=THOROUGH [2]=DEEP [3]=REPAIR)
	local _level=${_levelMap[${_inspectLevel}]}
	if [ $_level = "QUICK" ]; then
		_log 0 "${FUNCNAME}: running inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
		return $?
	elif [ $_level = "THOROUGH" ]; then
		_log 0 "${FUNCNAME}: running inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
	elif [ $_level = "DEEP" ]; then
		_log 0 "${FUNCNAME}: running inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --cached HEAD || return 1
		_log 0 "'git fsck --full --verbose'"
		${_git} fsck --full --verbose
		_gitFsckExit=$?
		_log 1 "git fsck exit status: '${_gitFsckExit}'"
	elif [ $_level = "REPAIR" ]; then
		_log 0 "${FUNCNAME}: running inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
		echo REPAIR
	else
		_log 3 "${FUNCNAME}: illegal level $_level"
		return 1
	fi
	#_gitDiffIndex=$(${_git} diff-index --quiet --cached HEAD -- 2>&1)
	#if [ $? = 0 ] && [ -z "${_gitDiffIndex}" ]; then
	#	_log 0 "'git diff-index --quiet --cached HEAD --' exited cleanly"
 	#	return 0
	#else
	#	if echo ${_gitDiffIndex} | grep ^"warning: index entry is a directory"; then
	#		_log 3 "an empty tree has been added"
	#		return 1
	#	else
	#		_log 3 "'git diff-index --quiet --cached HEAD --' complained: '${_gitDiffIndex}'"
	#		return 1
	#	fi
	#fi
}


__recover() {
	# check git status for objects in index not yet committed
	# we always want the index to match the latest commit...this is an exercise of
	# automatic repair when an add() operation fails completely
	# we will also improve the add() function to be more atomic...in the meantime,
	# this is a programatic way of detecting the blobs and mapped trees we added
	# but failed to commit
	local _gitDiff="${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(${_git} rev-parse HEAD)
	_isIndexClean || _log 3 "index is dirty"
	_inconsistentCount=$(${_gitDiff} | wc -l)
	#_lostFiles=$(${_gitDiff} #last=${data##*,} 
	_lostMaps=$(${_gitDiff} | cut -f5 -d' ')
	_log 2 "last commit id: ${_lastCommit}"
	_log 2 "inconsistent count: ${_inconsistentCount}"
	_log 2 "uncommitted files: ${_lostMaps}"
	_log 3 "to recover, write tree, find parent, commit tree, update HEAD"
	local _lostKeys=()
	for _map in ${_lostMaps}; do
		_lostKeys+=(${_map##*/})
	done
	printf '%s\n' "${_lostKeys[@]}" | sort | uniq
	# possibility of multiples
	# sort by unix seconds key
	# cat-file for first line (the commit message)
	# get
	#_log 0 "remove the d/ map in the index first"
	#${_git} update-index --remove --cacheinfo 10064,$_blobID,d/${_tag:1}/${_key}
	#${_git} rm --cached a/2023/01/30/1675145248
	#${_git} rm --cached d/germ/1675145248	
	# DONE BY HAND
	#_mapPrimaryKey 1675145105 bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	#_readBlob bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	#_mapTags 1675145105 bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	#_printCommitMsg
	#_doCommit
	#
	# TODO
	# try to recover less delicately
	# get diff between dirty index, stash it, and rebuild the index from the last
	# good commit.  option to restore stash presented.
	echo "find the last a/ entry:"
	${_git} --no-pager diff --cached --summary -- a/
	echo "stash it"
	${_git} --work-tree=${_germDir} stash
	echo "remove the cache"
	echo "revert to the last commit"
	echo "recover the one germ entry in stash????"
	for i in ls ${_germDir}/a/2023/02/01/; do
		${_git} ls-files
	done
}

_recover() {
	echo "find the last a/ entry:"
	${_git} --no-pager diff --cached --summary -- a/
  # create mode 100644 a/2023/02/02/1675389157
	# get the blobID for it
	# db991049c08b29dabac4344df518785cf12ec6da
	# reset the index to clean 
	${_git} --work-tree=${_germDir} reset --mixed
	## make sure the global blob VAR is empty (safety)
	[ -z ${_blobArray[0]+0} ] || _log 4 "global blob array set"
	_readBlob db991049c08b29dabac4344df518785cf12ec6da
	# read the blob
	# map the blob primary key
	_blobID=db991049c08b29dabac4344df518785cf12ec6da
	_key=1675389157
	_mapPrimaryKey $_key $_blobID
	[ -z ${_blobArray[0]+0} ] ||  _log 2 "blob read"
	# run through the tag mapper
	_firstWord=${_blobArray[0]%% *}
	_log 0 "WE WOULD be mapping first word $_firstWord...but experimenting"
	_mapBlob "d/${_firstWord}/${_key}" $_blobID
	_mapTags $_blobID
	# commit the transaction
	#_doCommit
}


_restoreLastCommit() {
	# when index reports any inconsistencies
	# clear the cache
	${_git} rm -r --cached
	# identify the last mangled commit
	echo "NOT SURE YET"
	# rebuild the index from the last commit
}

# 
# TODO also capture the git errors...this is being lost now
# and set -x is the only means of capturing the break



###############
###### SHELL
###############

_shell() {
	# enter (cd) into studio environment
	# change the command history file
	# change the prompt dynamically
	cd "${_studioDir}" || _log 4 "can not enter studio"
	HISTFILE="${_studioDir}/.germ_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _prompt=
	local _dirty=
	# embedded prompt function setting...to catch a dirty index for now
	_setPrompt() {
		_isIndexClean || _dirty="${boldred}X${reset}"
		if [[ ! -z ${_dirty:-} ]]; then
			_prompt="${prompt}${_studioDirName}${reset}:${label}${_germDirName}${reset} ${_dirty} > "
		else
			_prompt="${prompt}${_studioDirName}${reset}:${label}${_germDirName}${reset} > "
		fi
	}
	_setPrompt
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

germ: type ${green}help${reset} for guidance
      type ${red}stop${reset} to leave

HEREDOC

	local __input
	while IFS='' read -r -e -d $'\n' -p "${_prompt}" __input; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			cd $OLDPWD; exit 0
		elif [[ "${__input}" =~ (^help$|^h$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_listTags
		elif [[ "${__input}" =~ (^status$|^stat$) ]]; then
			_showStatus
			_isIndexClean || _log 3 "DIRTY INDEX"
		elif [[ "${__input}" =~ (^add$|^a$) ]]; then
			eval "${self}" add || true
		else
			eval "${self}" "${__input}" || :
			#_log 3 "command not valid: '${__input}'"
			#_printShellUsage
		fi
		_setPrompt
	done
}	

_irishExit() {
  echo -ne "\r${yellow}WARNING${reset}: ctrl-c detected; to resume, press R, to quit, press ENTER\n"
  read -s -t 15 -n 1 _ANS
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
  else
    _log 4 "user requested exit with ctrl-c"
  fi
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
  # if run without arguments, enter germ shell
	#[ -z "${_subCommand:-}" ] && _printUsage
	# not sure if launching the shell here makes sense
	# seems that display gets messed up
	_log 0 "${FUNCNAME[0]}: _subCommand: ${_subCommand:-}"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# validate the environment first
	_isEnvSufficient || _log 4 "cannot run until these problems are resolved"
	# do it
	#
	# figure out how to incorporate _shell correctly
	# launched with no args..._shell
	# _shell calls back when allowed
	# possibly check for tty?
	[[ -t 1 ]] && echo 'STDOUT is attached to TTY'
	[[ -p /dev/stdout ]] && echo 'STDOUT is attached to a pipe'
	[[ ! -t 1 && ! -p /dev/stdout ]] && echo 'STDOUT is attached to a redirection'
	if [ -z "${_subCommand:-}" ]; then
		_shell 
	elif [ -n "${_subCommand:-}" ]; then
		eval _"${_subCommand}"
	fi
	#[ -z "${_subCommand:-}" ] && _shell ||
	#[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

