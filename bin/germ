#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us
# derived from a working copy of dsink

# TO MY FUTURE SELF
# WHOSE MEMORY WILL STRUGGLE TO REMEMBER HOW THIS THING WORKS
# TOC MORE OR LESS:
# SCRIPT AND SHELL SETTINGS
# ENVIRONMENT SETTINGS
# DEFAULTS
# BASIC LOGGING FUNCTIONS
# HELPER FUNCTIONS
# PARAMETER PROCESSING FUNCTIONS
# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
# MAIN ENTRY AND CONTROL

# SCRIPT AND SHELL SETTINGS

# bash makin-it-hard settings
set -o errexit
set -o nounset
set -o pipefail

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(git gitdisk dsink tig vipe)


# ENVIRONMENT SETTINGS


# BEHAVIOR

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses normal output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=true

# OUTPUT

# some color
red=$(tput setaf 1)
#boldred=$(tput bold; tput setaf 1)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
prompt=$(tput setab 5; tput setaf 7)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)

# DEFAULT SETTINGS

# WORKING ENVIRONMENT
_studioDirName=studiodev
_studioDir="$(dirname ~/.)/${_studioDirName}"
# GERM lives inside studio (the master container)
_germDirName=germ
_germDir="${_studioDir}/${_germDirName}"
_germGitDisk="${_germDir}/.gitdisk"
_logFile="${_germDir}/germ.log"
# SET GIT COMMANDS for convenience and consistency
_git="git --git-dir=${_germGitDisk} --work-tree=${_germDir}"
# NOTE, future use may involve setting work-tree differently or locally

# global variables we use
self=$(basename $0)
# check if a logfile exists
[ -f "${_logFile}" ] && _canLog=true || _canLog=false

_prompt() {
	# hack to avoid fixing _log and include a PROMPT type
	# TODO: add this idea into _log to keep the "universal" claim
	echo -n "${prompt}USER${reset}: ${1} "
}

# LOGGING 

_log() {
	# global prompt and logging function
	# consults _DEBUG _SILENT and _LOG for behavior
	# TODO: add type for user PROMPT (ie USER interaction)
	# TODO: try and optimize...many calls for each log event (although the use
	# would never be bogged down since this is a single user system)
	# levels:
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true (and
	# there are functions (eg _format) that should never be SILENT)
	# set to 0 to force all logs into DEBUG pipeline
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	#local _canLog
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	# TODO: fix this...not using it as designed
	#declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	#declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	#local _level=${_i[${_logLevel}]}
	#local _color=${_c[${_logLevel}]}
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	# BUG HERE
	# if SILENT is true and _log = 4, then we don't exit as expected on FATAL
	# error
	if [ ${_SILENT} = true ] && [ ${_logLevel} = 4 ]; then
		exit 1
	elif [ ${_SILENT} = true ]; then
		return
	fi
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: $self: ${_logMessage}" && exit 1
	fi
}


# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database

for command specific usage, eg:
$ germ help add

EOF
exit 0
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git repo, keeping
minimal metadata and organizing with tree objects

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				_germDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_germDir="$(dirname ~/.)/studio/${_germDirName}"
				_logFile="${_germDir}/germ.log"
				_log 0 "${FUNCNAME[0]}: using alternative germ dir $_germDir"
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			status)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			*)
				_log 4 "_getSubcommand(): '$1' is not a subcommand"
				;;
		esac
		shift
	done
}	


_isEnvSufficient() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		fi
	done
	# check for germ dir (unless we are running create...this could use some
	# cleaning for clarification)
	if [ ! -d "${_germDir}" ] && [ ! ${_subCommand} = "create" ]; then
		_log 3 "found no ${_germDir}; run 'germ create' first"
		_sufficient=false
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}


# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
_getAddOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":i" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_log 0 "enabled inline mode"
				_inline=true
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	
# germ add
# two options
#		inline (invoked by add -i)
#			no tags allowed, naturally (bash interprets # as a comment)
#			tags allowed if escaped ("add -i \#<tag> followed by the entry")
#		buffer (add without args, calls an editor, the saved results comprise)
#			
# SUB COMMANDS

__list() {
	#local _gitdir="${_germGitDisk}"
	#local _git="git --git-dir=${_gitdir}"
  { ${_git} rev-list --objects --all
  ${_git} rev-list --objects -g --no-walk --all
  ${_git} rev-list --objects --no-walk \
        $(${_git} fsck --unreachable |
          grep '^unreachable commit' |
          cut -d' ' -f3)
}
}

_status() {
	#local _gitdir="${_germGitDisk}"
	#local _git="git --git-dir=${_gitdir}"
	_log 1 "studio dir name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 1 "'git fsck --full'"
	${_git} fsck --full
	#_log 1 "'git fsck --unreachable'"
	#${_git} fsck --unreachable
	#_log 1 "'git reflog'"
	#${_git} reflog
	#_log 1 "'git log --graph --reflog'"
	${_git} log --graph --reflog
	# the above runs into a pager and is quite nice and useful already
	# the below is someone else's custom formatting
# $ git config --global alias.graph \
#  "log --graph --all --format='%h %s%n        (%an, %ar)%d' --abbrev-commit"
	_log 2 "check out the 'git gc' command...does it leave stats?"
	_isIndexClean || _log 3 "INDEX IS DIRTY" && _log 1 "INDEX CLEAN"
	#_readBlob bb10
	#_recover
}

_list() {
	_log 1 "git 'ls-files -s'"
	${_git} ls-files -s $_workingParams
	# HACKED now
	_log 1 "git 'ls-tree -r HEAD'"
	${_git} ls-tree -r HEAD 
}

# TODO
# add virtual tracking...pointers to the last file entered
#
# /j/last		-->
#
# /j
# /j/new.0	-->	a/2023/01/30/1675144729
# /j/new.1	-->	and so on...an always flowing list, always updated
#
# /j/edited.0	--> d/jkl/1675134323
# /j/edited.1	--> and so on...adjust the depth here based on speed and screen
# space and use case 
#
# can we use the index but not commit all its noise?
# use it to track changes to an add object operation
# then remove it before the commit
#
# TODO
# define the tree index namespace and its use
# a/		primary key, hash of date, unix seconds key
# b/		workflow status
# c/		source
# d/		first word catalog
# e/		tag catalog
# f/
# g/
# h/
# i/
# j/
# k/
# l/
# m/
# n/
# o/
# p/
# q/
# r/
# s/
# t/
# u/
# v/
# w/
# x/
# y/
# z/

# NAMESPACE construction
# /a/		primary namespace key
#				YEAR/MONTH/DAY/UNIX_SECONDS
#				eg 2023/01/30/1675101655
# /b/		workflow status
#					new			:	added only
#					read		: viewed at least once
#					edited	: edited at least once
#					other operations: move, rename, delete ?
# thus, after adding one, then viewing it:
# /b/add/
# /b/read/1675101655
# /b/edited/
# each blob moves through namespaces following action on the blob
#
# /c/		source (a catalog of notebooks, etc, from whence the germ came)
# /d/		first word catalog
# /e/		tag catalog
# /f/		heuristic
#					matches /d and /e keywords from text and maps them
#					matches text indicators (cf, re, eg, ie, todo, etc)
#					matches operators (<,>,=,+,*,@,$...etc) [future]

# TODO
# make writes more atomic?
# 		j/atomic/last.key
# use j/atomic/key.add
# 		j/atomic/key.map
#			j/atomic/key.tree
#			j/atomic/key.commit
# check for consistency each time

# TODO: question: define line limit or not?  bash arrays have none
# read blob
_readBlob() {
	# arg 1 = blob ID
	# read a blob into a bash array
	# export the array into the global environment
	local _blobID=$1
	${_git} cat-file -e ${_blobID} &>/dev/null || return 1
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	if [ ${#_blobArray[@]} -ne 0 ]; then
		_log 1 "read blob ${_blobID:0:5}"
		_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
		export _blobArray
	else
		_log 3 "${_blobID} is empty"
		return 1
	fi
}

######################
# INDEX MANIPULATION

_mapPrimaryKey() {
	# arg 1 = primary key (unix seconds)
	# arg 2 = blobID
	# assumes global _blobArray
	# TODO add some sanity checks here
	local _key=$1
	local _blobID=$2
	local year=$(date -d @${1} +"%Y")
	local month=$(date -d @${1} +"%m")
	local day=$(date -d @${1} +"%d")
	local _keyPath="a/$year/$month/$day/${_key}"
	# UPDATE the index (ie maps blob to namespace...hashed date - key is seconds)
	${_git} update-index --add --cacheinfo 10064,$_blobID,${_keyPath}
	_log 1 "added ${_blobID} as ${_keyPath}"
}

_mapBlob() {
	# arg 1 = path
	# arg 2 = blobID
	[ $# -eq 0 ] && return 1
	local _path="${1}"
	local _blobID=${2}
	${_git} update-index --add --cacheinfo 10064,$_blobID,"${_path}"
	_log 1 "mapped ${_blobID:0:5} as ${_path}"
}

_mapFirstLine() {
	# take first line
	# replace space with dash
	# add to f/
	echo "first line processor"
}

_mapTags() {
	# arg 1 = key
	# arg 2 = blobID
	# check for tags on first line
	# assumes global _blobArray
	[ $# -ne 2 ] && return 1
	local _key="${1}"
	local _blobID=${2}
	local _line
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			_log 0 "blank line detected..skipping"
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			_log 0 "^# detected, checking for tag"
			_tag=${_line%% *}
			if [ -z "${_tag:1}" ]; then
				_log 0 "empty tag, skipping"
			else
 				_log 0 "found tag '${_tag:1}'"
				_mapBlob "e/${_tag:1}/${_key}" $_blobID 
				#${_git} update-index --add --cacheinfo 10064 $_blobID e/${_tag:1}/${_key}
				_log 1 "mapped ${_blobID:0:5} as ${_key} in tag space e/${_tag:1}"
			fi
		fi
	done
}

# i had a bug which opened my eyes to an interesting possibility
# i was adding the whole string (it was _workingParams or _message) as the
# commit message...which made git log and tig both show the germ itself nicely.
# i fixed the commit to use the first line instead of the whole message string
# and now the git log and tig both lost the bug.


# commit relies on _blobArray, using the first line as the commit msg
_doCommit() {
	# discrete operation...write the index as a commit
	_log 2 "commit msg= ${_blobArray[0]}"
	_commitMsg="${_blobArray[0]}"
	_tree=$(${_git} write-tree)
	_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
		_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_commitMsg")
	else
		_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_commitMsg}")
	fi
	_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	_log 1 "updated the HEAD reference"
	return 0
}	

_printCommitMsg() {
	# assumes global _blobArray
	_commitMsg="${_blobArray[0]}"
	echo "${_commitMsg}"
}

_add() {
	if [ ${_inline:-null} = "true" ]; then
		_log 1 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 4 "'add -i' cannot contain an empty message"
	else
		_message=$(vipe)
		_log 0 "vipe-produced entry: $_message"
		_workingParams="${_message}"
	fi
	_log 2 "message: ${_workingParams}"
	# set up primary key namespace mapping
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_key}"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_workingParams}")
	_log 1 "added the blob to the object store"
	_readBlob $_blobID 
	_mapPrimaryKey $_key $_blobID
	# map first word on first line to d/
	_firstWord=${_blobArray[0]%% *}
	_mapBlob "d/${_firstWord}/${_key}" $_blobID
	_mapTags $_key $_blobID
	_doCommit
}

__add() {
	# $_workingParams contains the string...we need to check if this is null as
	# some characters (like #) will be stripped out by bash unless we escape it.
	if [ ${_inline:-null} = "true" ]; then
		_log 1 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 4 "'add -i' cannot contain an empty message"
	else
		_message=$(vipe)
		_log 0 "vipe-produced entry: $_message"
		_workingParams="${_message}"
	fi
	# set up primary key namespace mapping
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_key}"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_workingParams}")
	_log 1 "added the blob to the object store"
	# READ the blob back...first confirmation
	# plus we will parse the blob now to build the metadata view
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
	# UPDATE the index (ie maps blob to namespace...hashed date - key is seconds)
	${_git} update-index --add --cacheinfo 10064 $_blobID ${_keyPath}
	_log 1 "added ${_blobID} as ${_keyPath}"
	# map first word on first line to d/
	_firstWord=${_blobArray[0]%% *}
	${_git} update-index --add --cacheinfo 10064 $_blobID d/${_firstWord}/${_key}
	_log 1 "mapped ${_blobID:0:5} as ${_key} in d/${_firstWord}"
	# check for tags on first line
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			# BUG Here...must not set tag to null string if there is no tag
			_tag=${_line%% *}
 			_log 0 "found tag '${_tag:1}'"
			${_git} update-index --add --cacheinfo 10064 $_blobID e/${_tag:1}/${_key}
			_log 1 "mapped ${_blobID:0:5} as ${_key} in tag space e/${_tag:1}"
		fi
	done
	# next create a tree object from the index
	# THIS IS A DISCRETE OPERATION...put in a function
	_tree=$(${_git} write-tree)
	_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
		_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_workingParams")
	else
		_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_workingParams}")
	fi
	_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	_log 1 "updated the HEAD reference"
	return 0
}
# git ls-files is the correct way to navigate the git tree we are creating here

_create() {
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_prompt "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z ${_studioName} ] || _studioDirName="${_studioName}"
	_prompt "enter studio path ["${_studioDir}"] "
	read _studioPath
	[ -z ${_studioPath} ] || _studioDir="${_studioPath}"
	_prompt "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	_prompt "enter germ gitdisk name ["${_germGitDisk}"] "
	read _germGit
	[ -z ${_germGit} ] || _germGitDisk="${_germGit}"
	_prompt "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_prompt "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_log 0 "studio dir name: ${_studioDirName}"
	_log 0 "studio path: ${_studioDir}"
	_log 0 "germ path: ${_germDir}"
	_log 0 "germ gitdisk: ${_germGitDisk}"
	_log 0 "germ user name: ${_userName}"
	_log 0 "germ user email: ${_userEmail}"
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk}
	else
		gitdisk create -b ${_germGitDisk}
	fi
  git config --global includeif.gitdir:"${_studioDir}".path "${_studioDir}/.gitconfig-studio"
  git config --global includeif.gitdir:"${_germGitDisk}".path "${_studioDir}/.gitconfig-studio"
	git config --file="${_studioDir}"/.gitconfig-studio user.name "${_userName}"
	git config --file="${_studioDir}"/.gitconfig-studio user.email "${_userEmail}"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

}

_isIndexClean() {
	${_git} diff-index --quiet --cached HEAD -- || return 1
}

_recover() {
	# check git status for objects in index not yet committed
	# we always want the index to match the latest commit...this is an exercise of
	# automatic repair when an add() operation fails completely
	# we will also improve the add() function to be more atomic...in the meantime,
	# this is a programatic way of detecting the blobs and mapped trees we added
	# but failed to commit
	local _gitDiff="${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(${_git} rev-parse HEAD)
	_isIndexClean || _log 3 "index is dirty"
	_inconsistentCount=$(${_gitDiff} | wc -l)
	#_lostFiles=$(${_gitDiff} #last=${data##*,} 
	_lostMaps=$(${_gitDiff} | cut -f5 -d' ')
	_log 2 "last commit id: ${_lastCommit}"
	_log 2 "inconsistent count: ${_inconsistentCount}"
	_log 2 "uncommitted files: ${_lostMaps}"
	_log 3 "to recover, write tree, find parent, commit tree, update HEAD"
	local _lostKeys=()
	for _map in ${_lostMaps}; do
		_lostKeys+=(${_map##*/})
	done
	printf '%s\n' "${_lostKeys[@]}" | sort | uniq
	# possibility of multiples
	# sort by unix seconds key
	# cat-file for first line (the commit message)
	# get
	_log 0 "remove the d/ map in the index first"
	#${_git} update-index --remove --cacheinfo 10064,$_blobID,d/${_tag:1}/${_key}
	#${_git} rm --cached a/2023/01/30/1675145248
	#${_git} rm --cached d/germ/1675145248	
	# DONE BY HAND
	#_mapPrimaryKey 1675145105 bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	_readBlob bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	_mapTags 1675145105 bb10ac176fb1a38211c0c26d3c57c23abd1ab9f6
	_printCommitMsg
	_doCommit
}


# 
# TODO also capture the git errors...this is being lost now
# and set -x is the only means of capturing the break

_irishExit() {
  echo -ne "\r${yellow}WARNING${reset}: ctrl-c detected; to resume, press R, to quit, press ENTER\n"
  read -s -t 15 -n 1 _ANS
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
  else
    _log 4 "user requested exit with ctrl-c"
  fi
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
  # if run without arguments, run and print _status
	[ -z "${_subCommand:-}" ] && _printUsage
	_log 0 "${FUNCNAME[0]}: _subCommand: $_subCommand"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# validate the environment first
	_isEnvSufficient || _log 4 "cannot run until these problems are resolved"
	# do it
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

