#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# SCRIPT AND SHELL SETTINGS
set -o errexit  # set -e
set -o nounset
set -o pipefail

###########################
# PREREQUISITES
###########################
 
# required commands
_requiredCommands=(git gitdisk dsink vipe fzf)

# recommended commands
_recommendedCommands=(git-sizer tig)

###########################
# ENVIRONMENT SETTINGS
###########################

# GLOBAL VARIABLES
# these never change in the context of a session
# these will be exported (in the case of fzf previews etc) 

# WORKING ENVIRONMENT
# _studioDirName is the umbrella or master namespace in which germ operates
_studioDirName=studiodev
# germ lives inside studio (into which it is designed to publish)
_germDirName=germ
# get the name of the script itself
self=$(basename $0)

# USER NAME
# the git username and email are used to create a short hash which identifies
# the user in the namespace.  it is set as a global variable and used in various
# places.  it can be overridden here.
# see _setUserUUID and _uuidGet
#_user=e291
#_user=

# BEHAVIOR

# TODO figure out a better means of knowing
# 1. is this an interactive shell session
# 2. is this part of a pipe
# 3. are we in our custom interactive shell (and does that matter?)
# set up logging and stdout stderr etc with traps
# possibly check for tty?
#[[ -t 1 ]] && echo 'STDOUT is attached to TTY'
#[[ -p /dev/stdout ]] && echo 'STDOUT is attached to a pipe'
#[[ ! -t 1 && ! -p /dev/stdout ]] && echo 'STDOUT is attached to a redirection'

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses normal output)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=false

# OUTPUT

# some color
red=$(tput setab 1; tput setaf 7)
boldred=$(tput setab 1 ; tput setaf 7)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
reset=$(tput sgr0)
label=$(tput setab 7; tput setaf 0)
prompt=$(tput setab 5; tput setaf 7)


# user output: types
# info		information only											blue text, green bg
# warn		warning																black text, yellow bg
# error																					white text, red bg
# fatal		error and exiting (out of trap)				black text, red bg, bold text?
# input		requires input												white text, cyan bg
# always expect fresh new line
# exception...after input...in which case, take care of that immediately

user=$(tput setab 6; tput setaf 7)
_prompt() {
	# used when user input is required
	printf "\n%s %s" "${user}USER${reset}" "${1} "
}

info=$(tput setab 2; tput setaf 0)
_info() {
	# prints info...multi-line messages are indented
	SAVEIFS=$IFS
	IFS=$'\n'
	_pList=(${1})
	IFS=$SAVEIFS
	if [[ ${#_pList[@]} -gt 1 ]]; then
		printf "%s %s\n" "${info}INFO${reset}" "${_pList[0]} "
		for (( i=1; i<${#_pList[@]}; i++ ))
		do
			printf "\t\t: %s\n" "${_pList[$i]} "
		done
	else
		printf "%s %s\n" "${info}INFO${reset}" "${1} "
	fi
}

warn=$(tput setab 3; tput setaf 0)
_warn() {
	# hack to display warning...need to fix up the whole _log idea
	#echo -e "${warn}WARN${reset} ${1} "
	#echo "${warn}WARN${reset} ${1} "
	printf "%s %s\n" "${warn}WARN${reset}" "${1}"
}

# LOGGING 

# 
# TODO also capture the git errors...this is being lost now
# and set -x is the only means of capturing the break
_log() {
	# overly complex global prompt and logging function
	# consults _DEBUG _SILENT and _LOG for behavior
	# TODO: add type for user PROMPT (ie USER interaction)
	# TODO: try and optimize...many calls for each log event (although the use
	# would never be bogged down since this is a single user system)
	# levels:
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true (and
	# there are functions (eg _format) that should never be SILENT)
	# set to 0 to force all logs into DEBUG pipeline
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	# TODO: fix this...not using it as designed
	declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	local _level=${_i[${_logLevel}]}
	local _color=${_c[${_logLevel}]}
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog:-false} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	# BUG HERE
	# if SILENT is true and _log = 4, then we don't exit as expected on FATAL
	# error
	if [ ${_SILENT} = true ] && [ ${_logLevel} = 4 ]; then
		exit 1
	elif [ ${_SILENT} = true ]; then
		return
	fi
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: $self: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: $self: ${_logMessage}" && exit 1
	fi
}

# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

alternate env settings:
 -a <name>  set the germ dir name to <name>
 -w <name>  set the master studio dir to <name> (assumes $HOME/<name>)


commands:
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database
 inspect             run tig on the germ git bare repo
 sizer               run github sizer tool on germ git bare repo

for command specific usage, eg:
$ germ help add

EOF
}

_printInfo () {
  cat << EOF

germ takes simple notes and adds them to a git repo, keeping
minimal metadata and organizing with tree objects

EOF
}


# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:w:" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
			a)
				_germDirName=$OPTARG
				# TODO find a better way of avoiding using key words as OPTARGs
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_warn "using alternative germ name '$_germDirName'"
				;;
			w)
				_studioDirName=$OPTARG
				[[ $OPTARG =~ add|edit|create|print ]] && _log 4 "$OPTARG not allowed"
				_warn "using alternative studio name '$_studioDirName'"
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			add)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getEditOpts
				return
				;;
			create)
				_log 0 "_getSubcommand(): '$1' called, checking for $1 flags"
				_subCommand=$1
				_getCreateOptions
				return
				;;
			list)
				_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			inspect)
				_subCommand=$1
				return
				;;
			status)
				#_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			recover)
				#_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			sizer)
				#_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			source)
				#_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			test)
				#_log 0 "_getSubcommand: $1"
				_subCommand=$1
				return
				;;
			*)
				#_log 3 "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
	# set (and print) the environment
	_info "setting up environment now"
	_studioDir="$(dirname ~/.)/${_studioDirName}"
	_germDir="${_studioDir}/${_germDirName}"
	_germGitDisk="${_germDir}/.gitdisk"
	_logFile="${_germDir}/germ.log"
	_gitWT="git --git-dir=${_germGitDisk} --work-tree=${_germDir}"
	_git="git --git-dir=${_germGitDisk}"
	[[ -f "${_logFile}" ]] && _canLog=true
	_log 0 "self=$self"
	_log 0 "_studioDirName=$_studioDirName"
	_log 0 "_studioDir=$_studioDir"
	_log 0 "_germDirName=$_germDirName"
	_log 0 "_germDir=$_germDir"
	_log 0 "_germGitDisk=$_germGitDisk"
	_log 0 "_logFile=$_logFile"
	_log 0 "_gitWT=$_gitWT"
	_log 0 "_git=$_git"
	_log 0 "git version= $($_git -v)"
	_log 0 "_canLog=${_canLog:-false}"
	_log 0 "_user=${_user:-unset}"
	_log 0 "_DEBUG=$_DEBUG"
	_log 0 "_SILENT=$_SILENT"
	_log 0 "_LOG=$_LOG"
}

_isEnvSufficient() {
	# check for required tools, report accordingly
	# TODO add recommended checks with _missing{0:name,1:name}
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		else
			_log 0 "${FUNCNAME}: ${_required} found"
		fi
	done
	# check for germ dir (unless we are running create...this could use some
	# cleaning for clarification)
	# if there is no germ dir and this
	if [ ! -d "${_germDir}" ]; then
		if [ -z "${_subCommand:-}" ]; then
			_log 3 "found no ${_germDir}; run 'germ create' first"
		 	return 1
		elif [ ! ${_subCommand:=} = "create" ]; then
			_log 3 "found no ${_germDir}; run 'germ create' first"
			_sufficient=false
		fi
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}

# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS

_getAddOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	#_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":i" flag "$@"; do
		case ${flag} in
			i)
				# inline add (no editor invoked)
				_log 0 "enabled inline mode"
				_inline=true
				;;
			?)
				 _warn "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getEditOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	#_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_warn "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getCreateOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	#_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	
# SUB COMMANDS


_showStatus() {
	# arg 1 = level [optional]
	# 0 = brief [default]
	# 1 = verbose
	local _level=${1:-0}
	_log 1 "$(${_git} --version)"
	_log 1 "studio name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 1 "germ user uuid: ${_user}"
	_log 1 "germ user: $(_printBlob ${_user})"
	_log 0 "'git count-objects --human'"
	_objectCount=$(${_git} count-objects --human)
	_log 1 "germ object count: ${_objectCount}"
	_lastCommit=$(${_git} rev-parse HEAD)
	_log 1 "last commit: ${_lastCommit}"
	_lastDate=$(${_git} --no-pager log -1 --format="%ad (%ah)")
	_log 1 "date of last commit: ${_lastDate}"
	_log 0 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 0 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 0 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
}

_status() {
	_log 1 "git version: $(${_git} --version)"
	_log 1 "studio dir name: ${_studioDirName}"
	_log 1 "studio path: ${_studioDir}"
	_log 1 "germ path: ${_germDir}"
	_log 1 "germ gitdisk: ${_germGitDisk}"
	_log 1 "germ user uuid: ${_userUUID:-}"
	_log 1 "germ current source: ${_currentSource:-}"
	${_git} commit-graph verify
	[ $? = 0 ] || _log 3 "'git commit-graph verify' returned an error"
	_log 1 "'git rev-parse --show-object-format HEAD'"
	${_git} rev-parse --show-object-format HEAD
	_log 1 "'git ls-tree -r HEAD' (ie what is in the last commit):"
	${_git} ls-tree -r HEAD
	_log 1 "'git ls-files --stage' (ie what is in the index):"
	${_git} ls-files --stage
	_log 1 "'git count-objects --human'"
	${_git} count-objects --human
	_log 1 "'git count-objects -vH'"
	${_git} count-objects -vH 
	_log 1 "count all git objects:"
	_log 0 "'git cat-file --batch-all-objects --batch-check | wc -l'"
	${_git} cat-file --batch-all-objects --batch-check | wc -l
	_log 1 "how many total objects:"
	_log 0 "'find ${_germGitDisk}/objects -type f | wc -l':" 
	find ${_germGitDisk}/objects -type f | wc -l
	_log 1 "git cat-file -p main^{tree}' (ie show tree namespace):"
	${_git} cat-file -p main^{tree}
	#_log 1 "'git fsck --full --verbose'"
	#${_git} fsck --full --verbose
	_log 1 "'git fsck --full'"
	_gitfsck=$(${_git} fsck --full)
	_gitFsckExit=$?
	while IFS= read -r line; do
		if [[ $line =~ ^dangling ]]; then
			echo "${yellow}$line${reset}"
		fi
	done <<< "${_gitfsck}"
	_log 1 "git fsck exit status: '${_gitFsckExit}'"
	_gitDiff="${_git} --no-pager diff --cached --summary HEAD"
	local _lastCommit=$(${_git} rev-parse HEAD)
	_inconsistentCount=$(${_gitDiff} | wc -l)
	_log 1 "last commit id: ${_lastCommit}"
	_log 1 "inconsistent count: ${_inconsistentCount}"
	if [[ ${_inconsistentCount} -ne 0 ]]; then
		_log 2 "'git diff --cached --summary HEAD' results:"
		${_git} --no-pager diff --cached --summary HEAD
	fi
	_isIndexClean || _log 3 "INDEX IS INCONSISTENT"
}


# TODO log output formatting
#${_git} log --graph --reflog
# the above runs into a pager and is quite nice and useful already
# the below is someone else's custom formatting
# $ git config --global alias.graph \
#  "log --graph --all --format='%h %s%n        (%an, %ar)%d' --abbrev-commit"

__test() {
	# attempt to repair a corrupt index
	# currently we see:
	# $ git --git-dir=/home/jason/studiodev/germ/.gitdisk diff-index --cached HEAD
	# :000000 100644 0000000000000000000000000000000000000000 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 A	test
	# $ git --git-dir=/home/jason/studiodev/germ/.gitdisk diff-index --quiet --cached HEAD
	# jason delphi ~ d=o $ echo $?
	# 1
	# somehow a path called 'test' was spuriously added
	# i want to identify the spurious path and remove it
	#${_gitWT} rm --cached test
	# the above command worked perfectly
	# repair work below	
	_mapBlob 7425ad6e810f7452292e26f5cf84db0df9e90dae c/dsd.f/self.catalog
	_mapBlob 372471866c62782e8744a981fd41fc7ad692d726 c/dsd.f/self.description
	#_deleteKey c/dsd.e/self.catalog
	#_deleteKey c/dsd.e/self.description
	#100644 7425ad6e810f7452292e26f5cf84db0df9e90dae 0	c/dsd.e/self.catalog
	#100644 372471866c62782e8744a981fd41fc7ad692d726 0	c/dsd.e/self.description
}

_listTags() {
	${_git} ls-files t/*/count.*
}

# problems include matching a tag '#' if ^'##' is found (as well as other
# non-alpha-numeric characters
_mapTags() {
	# arg 1 = blobID
	# check for tags (hash at first character of line)
	# assumes global _blobArray
	[ $# -ne 1 ] && return 1
	local _blobID=${1}
	local _line
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	for _line in "${_blobArray[@]}"; do
		if [ -z "${_line:-}" ]; then
			#_log 0 "blank line detected..skipping"
			continue	# ignore blank lines
		elif [ "${_line:0:1}" = "#" ]; then
			#_log 0 "^# detected, checking for tag"
			_tag=${_line%% *}
			if [ -z "${_tag:1}" ]; then
				true
			#	_log 0 "empty tag, skipping"
			else
 				#_log 0 "found tag '${_tag:1}'"
				# get the t/TAG/count.NUMBER
				_tagCount=$(${_git} ls-files t/${_tag:1}/count.* | cut -f3 -d/)
				#_log 0 "tag count for ${_tag:1} is ${_tagCount}"
				if [ -z "${_tagCount}" ]; then
					#_log 0 "first encounter with ${_tag:1}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/count.1"
					#_log 0 "added count.1 in t/${_tag:1}"
				else
					#_log 1 "found ${_tagCount#*.} tags for ${_tag:1}"
					${_git} --work-tree=${_germDir} update-index --remove "t/${_tag:1}/${_tagCount}"
					#_log 0 "removed ${_tagCount} from index at t/${_tag:1}/${_tagCount}"
					x=${_tagCount#*.}
					((x++))
					_tagCount=count.$x
					#_log 0 "set ${_tagCount}"
					${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"t/${_tag:1}/${_tagCount}"
					#_log 0 "updated t/${_tag:1} to ${_tagCount}"
				fi
				# update the tag-path
				_path="t/${_tag:1}/$_blobID/self"
				${_git} update-index --add --cacheinfo 10064,$_emptyBlob,$_path
				#_log 0 "mapped ${_blobID:0:5} in ${_path}"
			fi
		fi
	done
}

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	# TODO: consider what to do with tags
	local _maxLength=75
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	[ -z "${_commitMsgString}" ] && return 1
	echo "${_commitMsgString}"
}

# TODO add timer to catch left screen
# TODO use nano for certain functions, vim for others

_add() {
	local _germString=
	local _commitMsgString=
	local _primaryKey=
	# check if source is set already
	if _isSourceSet; then
		_currentSource=$(_getSource)
	fi
	if [ ${_inline:-null} = "true" ]; then
		#_log 0 "found an inline string: '$_workingParams'"
		[ -z "${_workingParams}" ] && _log 3 "${FUNCNAME}: 'add -i' cannot contain an empty message"
		_germString="${_workingParams}"
	else
		_message=$(vipe)
		_workingParams="${_message}"
		_germString="${_message}"
	fi
	_commitMsgString=$(_buildCommitMsg "${_germString}") || _log 4 "empty commit msg"
	#_log 0 "commit message: ${_commitMsgString}"
	# set up primary key namespace mapping
	_primaryKey=$(_getNewKey) || _log 4 "could not get a new unique key"
	# ADD the BLOB...get the BLOB id
	_blobID=$(${_git} hash-object --stdin -w <<< "${_germString}")
	_readBlob $_blobID 
	# map blob to primary key in a/
	_mapBlob ${_blobID} ${_primaryKey}
	# add blob to the source list in $_currentSource
	_addToSource ${_currentSource} ${_primaryKey}
	_mapTags $_blobID
	_doCommit "${_commitMsgString}"
}

_create() {
	# create a new germ database
	local _gitUserName=$(git config --global --get user.name)
	local _gitUserEmail=$(git config --global --get user.email)
	local _gitDisk=${_germGitDisk}
  trap _irishExit SIGINT
	_prompt "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z "${_studioName}" ] || _studioDirName="${_studioName}"
	#_prompt "enter studio path ["${_studioDir}"] "
	#read _studioPath
	#[ -z ${_studioPath} ] || _studioDir="${_studioPath}"
	_prompt "enter germ name ["${_germDirName}"] "
	read _germName
	[ -z ${_germName} ] || _germDirName="${_germName}"
	#_prompt "enter germ gitdisk name ["${_germGitDisk}"] "
	#read _germGit
	#[ -z ${_germGit} ] || _germGitDisk="${_germGit}"
	_prompt "enter preferred username [${_gitUserName}] "	
	read _userName
	[ -z ${_userName} ] && _userName="${_gitUserName}"
	_prompt "enter preferred email [${_gitUserEmail}] "	
	read _userEmail
	[ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_setEnv
	_info "studio dir name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "germ path: ${_germDir}"
	_info "germ gitdisk: ${_germGitDisk}"
	_info "germ user name: ${_userName}"
	_info "germ user email: ${_userEmail}"
	read -rsn1 -p "proceed? (y/n)" _yn
	[[ "$_yn" = "n" ]] && { _warn "aborting" ; exit ; }
	[ ! -d "${_germDir}" ] && mkdir -p "${_germDir}"
	if [ ${_DEBUG} = "true" ]; then
		gitdisk -d create -b ${_germGitDisk}
	else
		gitdisk create -b ${_germGitDisk}
	fi
  git config --global includeif.gitdir:"${_studioDir}".path "${_studioDir}/.gitconfig-studio"
  git config --global includeif.gitdir:"${_germGitDisk}".path "${_studioDir}/.gitconfig-studio"
	git config --file="${_studioDir}"/.gitconfig-studio user.name "${_userName}"
	git config --file="${_studioDir}"/.gitconfig-studio user.email "${_userEmail}"
	# _user is global var and short
	# _userUUID is blobid and long
	_userUUID=$(_uuidGet)
	export _user=${_userUUID:0:4}
	# map u/uuid/self to blob of git user string "user:email"
	# set /u/uuid/current as empty
	_mapBlob "${_userUUID}" "u/${_user}/self"
	_mapEmpty "u/${_user}/current"
	# add blob "germ created by jkl:jason@bloom.us (3c7c) $DATE"
	# write blob, get blobid (hash key)
	_blobID=$(_writeBlob "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)")
	# map blob to a/DATE/uuid.seconds
	_primaryKey=$(_getNewKey) || _log 4 "could not get a new unique key"
	_mapBlob ${_blobID} ${_primaryKey}
	_doCommit "${self} created by ${_userName}:${_userEmail} (${_user}) $(date)"

# we also will need to use show.untrackedfiles = no  ??
# git config --global log.date local  ... or check that these are already set in
# global

# TIP
# git help --config
# lists all the git config variables

# TODO assess and decide what to do if (remote possibility) a 4-char hash
# collision occurs from 2 unique users.  though by using 4 characters the odds
# are 1 in 

}

_sizer() {
	cd ${_germGitDisk}
	git-sizer --verbose
}

_inspect() {
	tig -C${_germGitDisk}
}


# TODO next
# update add()
# add the user
# decide whether to put the user:email blob or use an empty /self
# put the first blob in
# make the _userUUID a global VAR we get and set
# change the a/ path to be a/YEAR/MONTH/DAY/$userUUID.$unixSeconds
#
# add some sanity checks with user management...because the possibility of a
# lost or broken git config risks breaking the whole thing if we rely on the git
# config includeif
# then build _source()
# then put data in and move this to a production state
# much of the recovery functions will have to come in time
# additionally, migrating, merging, etc will have to follow later
# need to move data in and begin testing with actual data for the next phase,
# which is to begin building out the namespace mapping and the viewing,
# browsing, searching, and editing process...including blob naming, blob
# workflows, directory lattice, and project creation



####################################
# GERM PRIMITIVES
#
# _getNewKey		generate the unique filesystem name for the blob: $uuid.$seconds 
# _uuidGet			get or generate the uuid string to identify a user
# _setUserUUID	set the global var _user

_getNewKey() {
	# generate a new unique unix_time key path using date +%s and global _user
	# make sure it is unique...wait a couple seconds...otherwise return 1
	# print the key path
	local _key=$(date +%s)
	local _keyPath="a/$(date +%Y)/$(date +%m)/$(date +%d)/${_user}.${_key}"
	i=0
	while _doesKeyExist "${_keyPath}"; do
		sleep 0.5
		((i++))
		if [[ "$i" == '3' ]]; then
			return 1
		fi
	done
	echo "${_keyPath}"
}

_test() {
	#_uuidGen || echo "CANT"
	#_uuidGen "jkl:jason@bloom.us"
	#_uuidGen "Jason Lindemuth:jason@bloom.us"
	#_uuidGen "jason lindemuth:jason@bloom.us"
	#_uuidGen "periplume:periplume@gmail.com"
	#_uuidGen "j:a@b.c"
	#_mapEmpty "u/397d/self"
	#_mapEmpty "u/397/self"
	#_mapEmpty "u/39/self"
	#_uuidSet
	#_uuidGet || echo NNN
	#echo _uuidGetUnique
	#_uuidGetUnique 397db75f0d9b7dbf595db447b09c536a0edaac07
	#_uuidGetUnique e291707cbe17f3c6cd5a64993598142c280c238c
	#_uuidGetUnique 0cb834f2fe087b425b0cbb525643c23532663119
	#_doesUserExist 19140d16717ad524c9acee5ff9442daa2c580526 || echo "no1"
	#_doesUserExist 77c5f9cbbe8881fd6aa036b0024ec48608c813ad || echo "no2"
	#_doesUserExist 397db75f0d9b7dbf595db447b09c536a0edaac07 || echo "no3"
	#_doesUserExist e291707cbe17f3c6cd5a64993598142c280c238c || echo "no4"
	echo "WORK IT OUT"
	#_u=$(_uuidGen "dummy:dumb@dumber.com")
	#echo "_userUUID=$_u"
	#_doesUserExist $_u && echo "$_u is NOT new"
	#_userAdd $_u "dummy:dumb@dumber.com"
	#_uuidGen
	_userPrint
	_userAdd "dumbdumb:dumb@dumber.com" 
	echo "CHECKING e291"
	_userPrint e291
	echo "CHECKING 3c7c"
	_userPrint 3c7c
	echo "CHECKING 32"
	_userPrint 32
	echo "checking existing"
	_userString="jkl:jason@bloom.us"
	_userAdd "$_userString" || _warn "user '$_userString' exists"
	echo "checking no arg"
	_userAdd || _warn "useradd failed"
	_userAdd "jason lindemuth:jason@bloom.us"
}

# TODO
# for database maintenenace...check for dangling blobs
# brute force
# git gc 

##########
# _user
##########
# global var: _user = user "handle" (truncated hash)
# global var: _userUUID = full user hash
# 
# methods
# _uuidGen				generate the user uuid (_userUUID)
# _doesUserExist	check full _userUUID with _printBlob (no user match)
# _userAdd				using _userUUID, find the shortest match and create user
# _userSet				set the global _user and u/$_user/current
# _userPrint			print user details

#_userSet() {
#	# arg 1 = _user [optional]
#	# check for global var _user (override)
#	# validate this user...return if no such user exists
#	local _u
#	local _uuid
#	# if no arg supplied
#	if [ -z "${1:-}" ]; then
#		# and if _user was not set (manually)
#		if [ -z "${_user}" ]; then
#			# try to get the user from u/*/current
#			_u=$(_getKeyValue u/*/current)
#			_uuid=$(_getBlobID u/${_u}/self)
#		# _user was set (manually) in the script
#		else
#			_u=$_user
#			if _doesKeyExist "u/${_u}/self"; then
#				_uuid=$(_getBlobID u/${_u}/self)
#			else
#				_warn "$_user is not valid"
#				exit
#			fi
#		fi
#	# _user was supplied as $1
#	else
#		# UNFINISHED
#		_u=$1
#	fi
#}

_userPrint() {
	# arg 1 = _user [optional]
	local _l_user=${1:-${_user:-unset}}
	local _l_name
	local _l_email
	local _l_us
	_info "supplied: '${1:-}'"
	_info "checking for '${_l_user}'"
	_info "global: _user= '${_user:-unset}'"
	_info "global: _userUUID= '${_userUUID:-NULL}'"
	_info "index: user '${_l_user}' _userUUID= '$(_getBlobID u/${_l_user}/self)'"
	_info "index: 'current' user= $(_getKeyValue u/*/current)"
	_l_us=$(_readKey u/${_l_user}/self)
	_info "index: user name= '${_l_us%%:*}'"
	_info "index: user email= '${_l_us##*:}'"
}

_userAdd() {
	# arg 1 = "user:email"
	# get the userUUID
	# check if the user exists
	# if not, find the shortest user handle
	# add the blob ; get the blobID
	# map the blob
	# check for u/*/alpha
	# mapEmpty if first user
	# _mapBlob /u/$truncation/self -> blobID
	local _minUserLength=3
	local _blobID
	local _userUUID
	local _user
	local _userName
	local _userEmail
	local _userString="${1:-}"
	[ -z "${1:-}" ] && { _warn "no user name supplied" ; return 1 ; }
	# validate user string ( "name string" : "email string")
	_userName="${_userString%%:*}"
	_userEmail="${_userString##*:}"
	[ "${_userString}" = "${_userName}:${_userEmail}" ] || { _warn "'${_userString}' malformed" ; return 1 ; }
	# generate UUID
	_userUUID=$(_uuidGen "${_userString}")
	_doesUserExist "${_userUUID}" && { _warn "'${_userUUID} ${_userString}' exists" ; return 1 ; }
	# write the unique user string
	_blobID=$(_writeBlob "${_userString}")
	# look for shortest user handle
	while _doesKeyExist "u/${_blobID:0:${_minUserLength}}/self"; do
		((_minUserLength=_minUserLength+1))
	done
	# map the user to u/
	_user=${_blobID:0:${_minUserLength}}
	_mapBlob ${_blobID} "u/${_user}/self"
	# return the user name
	echo $_user
}

_doesUserExist() {
	# arg 1 = _userUUID (full hash)
	_printBlob "${1}" || return 1
}

_uuidSet() {
	# set (or validate) the global var _user
	local _user=	#unset global for testing
	local _minUserLength=2
	# if global _user is not set
	if [ -z ${_user} ]; then
		_userUUID=$(_uuidGen)
		echo "got ${_userUUID}"
		echo "min trunate ${_userUUID:0:${_minUserLength}}"
		# check if user exists (using _userMinLength to find shortest unique key)
		while _doesKeyExist "u/${_userUUID:0:${_minUserLength}}/self"; do
			echo "matched ${_userUUID:0:${_minUserLength}}"
			((_minUserLength=_minUserLength+1))
		done
		echo "unique ${_userUUID:0:${_minUserLength}}"
		#export _user=${_userUUID:0:4}
	else
		_doesKeyExist "c/${_user}/self" || echo "$_user exists"
		# _user was set manually
		# validate whether _user exists in u/$_user
	fi
}

_uuidGen() {
	local _u
	local _e
	local userstring
	local uuid
	if [[ -z "${1:-}" ]]; then
		_u=$(${_git} config --get user.name &>/dev/null) || return 1
		_e=$(${_git} config --get user.email &>/dev/null) || return 1
		userstring="${_u}:${_e}"
	else
		userstring="${1}"
	fi
	uuid=$(echo "${userstring}" | ${_git} hash-object --stdin)
	echo ${uuid}
}

# OLD FUNCTIONS
_uuidGet() {
	# arg 1: user:email string [optional...uses 'git config' otherwise]
	# using hash-object, generate a unique uuid
	# truncated, it serves the u/user field and the primary key as $uuid.$seconds
	local _u
	local _e
	local userstring
	local uuid
	if [[ -z "${1:-}" ]]; then
		_u=$(${_git} config --get user.name &>/dev/null) || return 1
		_e=$(${_git} config --get user.email &>/dev/null) || return 1
		userstring="${_u}:${_e}"
	else
		userstring="${1}"
	fi
	uuid=$(echo "${userstring}" | ${_git} hash-object --stdin)
	echo $_u $_e
	echo ${uuid}
}

_setUserUUID() {
	local _minUserLength=2
	# set the global var used in file mapping (if it is empty)
	if [ -z ${_user} ]; then
		# if running create...just leave it empty (it will get set in _create()
		[ "${_subCommand:-}" = create ] && return 0
		# otherwise, set the global var
		_userUUID=$(_uuidGet)
		export _user=${_userUUID:0:4}
	fi
	# TODO change the UUID to a variable-length string, with a min of 1-4 so that
	# in very small environments one can choose to be 'c' or 'e2'...ans when a new
	# user hash collides...increase the user string by as many characters as
	# necessary to make unique
	# this solves (i think) any collision problem, either with the potential
	# merging of germs from 2 users as well as the uuids...although a merge of 2
	# would potentially find two uuids matching...in which case much modification
	# would be necessary...but that condition is way too far out to worry
	# about...
}

######################################
# GIT PRIMITIVES
#
# generic git interface functions we use
# _writeBlob			write a blob...return a blobID
#	_readBlob				read a blob into a bash array and export as global var
# _printBlob			print the contents of a blob to stdout
# _mapBlob				add an entry in the index pointing to the blobID
# _mapEmpty				write an empty blob as a key to a path (eg u/$uuid/current)
# _doCommit				commit changes to the repo
# _doesKeyExist		check for an existing key in namespace (eg t/$tag/catalog/x)
# _isIndexClean		check the integrity and state of blobs and maps
# TODO separate _writeBlob and _putBlob?
# _writeBlob should add a key
# _putBlob should only put a blob in and return the blobID
# _getBlobID			given an index, return the blobID

_getBlobID() {
	# arg 1 = key
	${_git} ls-files --stage "${1}" | cut -f2 -d' '	
}

_writeBlob() {
	# arg 1 = blob
	# return blobID
	local blobID
	[ -z "${1:-}" ] && return 1
	blobID=$(${_git} hash-object --stdin -w <<< "${1}")
	echo "${blobID}"
	# TODO improve this to avoid errors
	# catch non-zero exit of hash-object and return that value
}

_readBlob() {
	# arg 1 = blob ID
	# read a blob into a bash array
	# export the array into the global environment for further use
	local _blobID=$1
	${_git} cat-file -e ${_blobID} &>/dev/null || return 1
	readarray -t _blobArray < <(${_git} cat-file -p ${_blobID})
	if [ ${#_blobArray[@]} -ne 0 ]; then
		#_log 1 "read blob ${_blobID:0:5}"
		#_log 1 "found ${#_blobArray[@]} line[s] in the new blob"
		export _blobArray
	else
		#_log 3 "${_blobID} is empty"
		return 1
	fi
}

_printBlob() {
	# arg 1 = blob ID
	# print the contents of the blob to stdout
	${_git} cat-file -p ${1} 2>/dev/null || return 1
}

_mapBlob() {
	# arg 1 = blobID (full sha)
	# arg 2 = path
	[[ -z "${1:-}" || -z "${2:-}" ]] && return 1
	#_log 0 "${FUNCNAME}: git update-index --add --cacheinfo 10064,${1},${2}"
	${_git} update-index --add --cacheinfo 10064,"${1}","${2}"
}

_mapEmpty() {
	# arg 1 = path
	[ -z "${1:-}" ] && return 1
	_emptyBlob=$(${_git} hash-object -w --stdin </dev/null)
	#_log 0 "${FUNCNAME}: git update-index --add --cacheinfo 10064,${_emptyBlob},${1}"
	${_git} update-index --add --cacheinfo 10064,$_emptyBlob,"${1}"
# NOTE this is a functional equivalent of git add --intent-to-add, with the
# exception that command expects a work-tree, while we have none
}

_doCommit() {
	# discrete operation...write the index as a commit
	#_log 0 "commit msg: '${1}'"
	_commitMsg="${1}"
	_tree=$(${_git} write-tree)
	#_log 1 "created tree object ${_tree}"
	# next make sure there is a parent
	if ${_git} rev-list --max-parents=0 HEAD &>/dev/null; then
		_parent=$(${_git} rev-list -n1 --all HEAD)
	#	_log 1 "found a parent: ${_parent}"
		_commit=$(${_git} commit-tree $_tree -p $_parent -m "$_commitMsg")
	else
	#	_log 1 "found no parent"
		_commit=$(${_git} commit-tree $_tree -m "[genesis] ${_commitMsg}")
	fi
	#_log 1 "created the commit object ${_commit}"
	${_git} update-ref HEAD "${_commit}"
	#_log 1 "updated the HEAD reference"
	return 0
}	

_doesKeyExist() {
	# arg 1 = key (namespace path)
	# return 0 if true
	# return 1 if false (no key exists)
	${_git} ls-files --error-unmatch "${1}" &>/dev/null || return 1
}

_isIndexClean() {
	${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
# TODO
# improve this
# 1. report on a/ for blob changes
# 2. check for state (ie changed source)
}

# TODO change this from checking the index whole to checking:
# a/ for dropped (dangling) blobs
# ie ignore c/ which icludes state...which we can tolerate
__isIndexClean() {
	# arg 1 = level (0-3) [optional...0 is default]
	# 0 normal...just check the basics and return 0/1
	# 1 deep...run the full checks
	# to override the global...set the first var
	local _inspectLevelOverride=
	local _inspectLevel=${_inspectLevelOverride:-${1:-0}}
	local _levelMap=([0]=QUICK [1]=THOROUGH [2]=DEEP)
	local _level=${_levelMap[${_inspectLevel}]}
	if [ $_level = "QUICK" ]; then
		#_log 0 "${FUNCNAME}: running index inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --quiet --cached HEAD 2>&1 >/dev/null || return 1
		return $?
	elif [ $_level = "THOROUGH" ]; then
		#_log 0 "${FUNCNAME}: running index inspect level ${_inspectLevel}: ${_level}"
		${_git} diff-index --cached HEAD || return 1
		#_log 0 "'git fsck --full --verbose'"
		${_git} fsck --full --verbose
		_gitFsckExit=$?
		#_log 1 "git fsck exit status: '${_gitFsckExit}'"
	elif [ $_level = "DEEP" ]; then
		#_log 0 "${FUNCNAME}: ${_inspectLevel}: ${_level} not implemented yet"
		return 1
	else
		#_log 3 "${FUNCNAME}: illegal level $_level"
		return 1
	fi
}


################
# SOURCE
################

# source is an exclusive category...an entity (blob or germ) cannot be a member
# of more than one source.  an entity can be without a source (ie source=null)
# it can also be called 'context'
# the 'source' is a generic organizing category and can be used in a variety of
# ways.  when it is set, all new germ entries will be cataloged (logged) into
# the source log c/$source/self.catalog
# the source catalog file:
# a non-sorted list of blobs added to the 'category'
#
# methods
# _addToSource		add a blob (key: a/2022/10/01/$uuid.$seconds) to
# c/$source/self.catalog file
#
# the above is in the context of a blob
#
# in the context of the ui, $source can be:
# 1. unset				_currentSource=()
# 2. set to one		_currentSource=("lgb-12-jan-22")
# 3. set to many	_currentSource=("lgb-12-jan-22" "lgb-7-jun-22")
# 4. set to "set" 	future idea: define a super-set
#
# in the context of _add()
# when _currentSource=(), blob is added without a source
# when _currentSource=(x), blob is added to source=x
# when _currentSource=(x,y), user is prompted to choose x/y or null

_addToSource() {
	# arg 1 = source name
	# arg 2 = key to blob
	local _cat=
	local _id=
	#_doesKeyExist c/${1}/self.catalog && _currentCat=$(_getBlobID "c/${1}/self.catalog")
	if _doesKeyExist c/${1}/self.catalog; then
		_currentCat=$(_getBlobID "c/${1}/self.catalog")
		_cat=($(_printBlob "${_currentCat}"))
	else
		_cat=()
	fi
	_cat+=(${2})
	_id=$(_writeBlob "$(printf '%s\n' ${_cat[@]})")
	_mapBlob "${_id}" "c/${1}/self.catalog"
}

_getSource() {
	# print the current SOURCE
	# read c/SOURCE/current
	x=$(${_git} ls-files c/*/current)
	x=${x#c/*}
	x=${x%/*}
	echo ${x}
}

_isSourceSet() {
	# no args
	# check for c/*/current
	# return 0 if true
	# return 1 if false
	_doesKeyExist c/*/current
}

_isSourceNew() {
	# arg 1 = new source name
	# checks for c/$1/self
	# if it exists, return 1 (no it is not new)
	# if it does not exist, return 0 (yes it is new)
	! _doesKeyExist "c/${1}/self"
}

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	_isSourceSet && _deleteKey "c/*/current"
	_mapEmpty "c/${1}/current"	
}

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	_id=$(_writeBlob "${1}")
	_mapBlob "${_id}" "c/${1}/self"
	_desc=$(_writeBlob "${2}")
	_mapBlob "${_desc}" "c/${1}/self.description"
	_doCommit "[source] added ${1}"
}

# germ methods required
# _getKeyValue (boolean)
# _deleteKey
# _readKey
# _listKeys
# _updateKey
#
# germ Bkey is a boolean or binary flag which indicates something
# it is exclusive in its namespace...ie c/*/NAMESPACE can only contain one Bkey
# its first use is with indicating the current user u/$UUID/current
# it also is used to indicate the current notebook source with c/$SOURCE/current
# it uses _mapEmpty to map an empty blob
# it refers to its parent directory in the namespace
# METHODS USED
# _doesKeyExist		(git)
# _deleteBkey			(germ bkey)
# _insertBkey			(germ bkey)
# _getBkeyValue		(germ bkey)
#
# germ Key is used similarly except that it contains information beyond an
# exclusive boolean setting
# ex. u/$UUID/self points to a blob from which the $UUID is derived, the string
# contianing the "user name:user email" used by git
# the information in the blob to which self points is arbitrarily defined by the
# use...u/*/self --> "user name:user email"
# c/*/self --> "source name"
# additionally, a key can contain additional attributes, eg c/*/self.description
# which contains the user-supplied description of the source
# the self key is used to enforce uniqueness and map into namespace the
# truncated hash
#
# PROBLEM I MUST ADDRESS...using the truncated HASH introduces a BUG...in that
# there is a remote possibility that 2 unique "keys" (2 different user:email
# strings eg which produce a hash whose first x characters happen to collide)
# ie...using the truncated hash in the namespace defeats the purpose.  USE the
# name in the namespace
# JUST DONT DO IT...
# INSTEAD...use the whole hash for the user id and never worry
# UNLESS...the user changes his email address
# SO for u/ we need to hash the username OR invent some other workaround to
# allow changed emails...or just abandon using the hash at all
#
# METHODS USED
# _doesKeyExist
# _readKey
# _listKeyAttributes
# _updateKey

_getKeyValue() {
	# arg 1 = key eg c/*/current
	# prints value from c/$value/$key
	${_git} ls-files "${1}" | cut -f2 -d/
}

_getKeyList() {
	# arg 1 = key space eg c/$source/self.*
	${_git} ls-files "${1}" | cut -f3 -d/
}

_deleteKey() {
	# arg 1 = key
	${_git} --work-tree=${_germDir} rm --cached --quiet "${1}"
	# THIS SHOULD be made more discrete
	# this REMOVES all keys!!!
}

_readKey() {
	# given key, eg c/$source/self.description
	# get the blob id
	# print the blob
	local _blobid
	_blobid=$(${_git} ls-files --stage ${1} | cut -d' ' -f2)
	if [ -z ${_blobid} ]; then
		echo "error, blob does not exist"
	else 
		_printBlob ${_blobid}
	fi
}
# exporting these functions to give fzf access to them
export -f _readKey
export _git
export -f _printBlob
export -f _doesKeyExist

_getSourceList() {
	# create a list from c/*/self
	${_git} ls-files --stage c/*/self | cut -f2 -d/
}

_printSourceEntities() {
	# arg 1 = source
	if _doesKeyExist c/${1}/self.catalog; then
		_readKey c/${1}/self.catalog
	else
		return 1
	fi
}
export -f _printSourceEntities

_getSourceCount() {
	# arg 1 = source
	_printSourceEntities ${1:-} | wc -l
}
export -f _getSourceCount

# source methods
# _isSourceSet		check for c/*/current
# _getSource			return c/$source/current
# _setSource			remove c/*/current (if set) and add c/$source/current 
# _addSource			user dialog to add new and (optionally) set current
#
# source name: eg lgb-12Jan2023
# source description: arbitrary text describing source


#
# TODO future _source operations...merge notebooks, split notebooks, archive,
# and print
#
_source () {
	local _currentSource
	export _maxLength=25
	# check if source is set already
	if _isSourceSet; then
		_currentSource=$(_getSource)
	fi
	######################
	#### MAIN MENU
	######################
	_mainMenu() {
	local _mainSelection
	_showOptions() {
	_currentSource=$(_getSource)
	echo -ne "
    current source: '${green}${_currentSource}${reset}' [$(_getSourceCount ${_currentSource})]

    c) change current source
    s) show details
    l) list entities
    e) edit description
    r) rename current source
    a) add new source
    m) merge two sources (future)
    ?) help
    q) return to germ

"
}
	_showOptions
	_previewSource() {
		# used during source change...shows description and entity count
		echo "source: $1"
		echo "entities: $(_getSourceCount $1)"
		echo
		echo "----DESC---------------------------"
		_readKey c/$1/self.description
	}
	export -f _previewSource
	_chooseSource() {
		# fzf-based chooser function
		local _newSourceName
		local _fzfPrompt="--prompt=TYPE-TO-FILTER> --info=hidden"
		local _fzfColor="--color=bg:#222222,preview-bg:#333333,header:yellow"
		local _fzfHeader="--header=choose from the list above"
		local _fzfPreview="--preview=_previewSource {} --preview-window=50%"
		local _fzfBack="--bind=backward-eof:clear-query"
		#local _fzfEsc="--bind=esc:cancel --bind=enter:accept-non-empty --bind=ctrl-c:cancel"
		local _fzfEsc="--bind=esc:cancel --bind=enter:accept-non-empty"
		_newSourceName=$(_getSourceList | fzf ${_fzfBack:-} ${_fzfEsc} ${_fzfPrompt} "${_fzfColor}" "${_fzfHeader}" "${_fzfPreview}")
		echo ${_newSourceName}
	}
	while read -r -s -n 1 -p"$(_prompt 'enter selection [? for help]')" _mainSelection; do
		case $_mainSelection in
 			c)
				_setSource $(_chooseSource) || _warn "aborted source change"
				_showOptions
				;;
			s)
				_info "current source: ${_currentSource}"
				_info "description: $(_readKey c/${_currentSource}/self.description)"
				;;
			e)
				_newDescription=$(_readKey "c/${_currentSource}/self.description" | vipe)
				_id=$(_writeBlob "${_newDescription}")
				_mapBlob "${_id}" "c/${_currentSource}/self.description"
				_doCommit "[source] updated ${_currentSource} description"
				;;
			a)
				_interactiveSourceAdd
				;;
			l)
				_info "entities   : $(_printSourceEntities ${_currentSource})"
				;;
			r)
				_renameSource "${_currentSource}"
				;;
			q)
				echo
				return
				;;
			h|\?)
				_info "use 'source' to add and manage media source list"
				_info "eg, naming notebooks, sets of papers, etc"
				_info "a notebook name is used as a virtual category"
				_showOptions
				;;
			$'\e')
				#_warn "escape key detected"
				# read and ignore escape sequences (including esc)
				read -rsn1 -t .002 tmp || { _warn "esc key not allowed" ; continue ; }
				if [[ "$tmp" == "[" ]]; then
					read -rsn1 -t .002 tmp || _warn "can't read any more"
					case "$tmp" in
						# ignore arrow keys
						"A"|"B"|"C"|"D") { _warn "arrow keys not allowed" ;  } ;; 
						# ignore insert and delete
						"2"|"3") { _warn "insert and delete keys not allowed" ; } ;; 
						# ignore home and end
						"H"|"F") { _warn "home and end keys not allowed" ; } ;; 
						# ignore all the rest
						*) { _warn "key '$tmp' not allowed" ; } ;;
					esac
				else
					_warn "ignoring escape key '$tmp'"
				fi
				# flush out stdin if necessary
				read -rsn6 -t .002 || continue 
				;;
			$'\177')
				# catch control characters
				#_warn "control character detected; ignoring"
				continue
				;;
			?)
				_warn "wrong selection ['${_mainSelection}']; try again"
				;;
			esac
		done
	}

	##########################
	### MENU FUNCTIONS
	##########################
	_renameSource() {
				# TODO add a default into the fzf query string here --with the existing
				# source name
		local _oldName="${1}"
		local _newName
		_interactiveSourcePicker _newName
		_id=$(_writeBlob "${_newName}")
		_mapBlob "${_id}" "c/${_newName}/self"
		for i in $(_getKeyList "c/${_oldName}/self.*"); do
			_blobID=$(_getBlobID "c/${1}/${i}")
			_mapBlob "${_blobID}" "c/${_newName}/${i}"
		done
		_setSource "${_newName}"
		_deleteKey "c/${_oldName}/self"
}

	_interactiveSourcePicker() {
		# smaller function...one job...pick a new source name
		# need to modify for better variable passing
		# arg 1 = caller's variable name
		local __name=$1
		_validateName(){
			# function used within fzf preview window to assist in the selection of a
			# source name
			local _newSourceName
			local lengthStatus
			local avail
			local allowedChars="n/a"
			local lead="n/a"
			local last="n/a"
			local repeat="n/a"
			local acceptable="NO"
			_cStat() {
				# arg 1 = key word
				# print the key word in a set color
				[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
				[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
				[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
				echo -n "${1}"
				tput sgr0 
			}
			# export to fzf for --preview
			export -f _cStat
			# validate the name first
			if [[ ${#1} -lt 3 ]]; then
				lengthStatus="TOO SHORT"
				avail="n/a"
			elif [[ ${#1} -gt ${_maxLength} ]]; then
				lengthStatus="TOO LONG"
				avail="n/a"
			else
				lengthStatus="OK"
				_doesKeyExist c/${1}/self && { avail="NO" ; acceptable="NO" ; } || { avail="YES" ; acceptable="YES"; }
			fi
			[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
			[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
			# print the validation info into the fzf preview window	
			echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
			[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
			printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
			printf "unique: %36s\n" "$(_cStat "${avail}")"
			printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
			printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
			printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
			printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
			echo "-----------RULES------------------"
			echo "the name must be unique"
			echo "max length is ${_maxLength}, min is 3"
			echo "lower case and numbers only"
			echo "non alpha-numeric characters allowed:"
			echo " - dash (-)"
			echo " - underscore (_)"
			echo " - dot (.)"
			echo " ^ these cannot be first or last"
			echo " ^ cannot be repeated (eg --)"
			echo
			echo "------SELECTED SOURCE DESCRIPTION------------"
			_readKey c/${2}/self.description
		}
		# export function to fzf for --preview
		export -f _validateName
		local _fzfFalse="fzf --bind=enter:print-query --print-query --exact "
		local _fzfPrompt="--prompt=TYPE-NEW-NAME> --info=hidden"
		local _fzfColor="--color=bg:#222222,preview-bg:#333333,header:yellow"
		local _fzfHeader="--header=existing above, guidance right >"
		local _fzfPreview="--preview=_validateName {q} {} --preview-window=50%"
		local _fzfBack="--bind=backward-eof:change-prompt(ENTER-NEW-NAME>)"
		local _fzfEsc="--bind=esc:clear-query"
		_doesKeyExist c/* || local _fzfSeed="--query=sample"
		# this fzf command allows us to use as a "reverse" or false finder...ie we
		# use the fzf results to show a list from which we cannot choose one of the
		# already existing members of the list
		while true; do
			_newSourceName=$(_getSourceList | ${_fzfFalse} ${_fzfBack} ${_fzfEsc} ${_fzfPrompt} ${_fzfSeed:-} "${_fzfColor}" "${_fzfHeader}" "${_fzfPreview}")
			if _isSourceNameValid "${_newSourceName}"; then
				_prompt "'${_newSourceName}' is valid, create? (y/n/q) "
				read -r -s -n 1 _ynq
				[[ "${_ynq:-}" = "y" ]] && break
				[[ "${_ynq:-}" = "q" ]] && return
				[[ "${_ynq:-}" = "n" ]] && continue
			else
				_warn "'${_newSourceName}' is not a valid name"
				_prompt "try again? (y/n) "
				read -r -s -n1  _yn
				[[ "${_yn:-}" = "y" ]] && continue
				[[ "${_yn:-}" = "n" ]] && return
			fi
		done
		eval ${__name}=${_newSourceName}
	}


	_interactiveSourceAdd() {
		_validateName(){
			# function used within fzf preview window to assist in the selection of a
			# source name
			local lengthStatus
			local avail
			local allowedChars="n/a"
			local lead="n/a"
			local last="n/a"
			local repeat="n/a"
			local acceptable="NO"
			_cStat() {
				# arg 1 = key word
				# print the key word in a set color
				[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
				[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
				[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
				echo -n "${1}"
				tput sgr0 
			}
			# export to fzf for --preview
			export -f _cStat
			# validate the name first
			if [[ ${#1} -lt 3 ]]; then
				lengthStatus="TOO SHORT"
				avail="n/a"
			elif [[ ${#1} -gt ${_maxLength} ]]; then
				lengthStatus="TOO LONG"
				avail="n/a"
			else
				lengthStatus="OK"
				_doesKeyExist c/${1}/self && { avail="NO" ; acceptable="NO" ; } || { avail="YES" ; acceptable="YES"; }
			fi
			[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
			[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
			[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
			# print the validation info into the fzf preview window	
			echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
			[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
			printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
			printf "unique: %36s\n" "$(_cStat "${avail}")"
			printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
			printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
			printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
			printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
			echo "-----------RULES------------------"
			echo "the name must be unique"
			echo "max length is ${_maxLength}, min is 3"
			echo "lower case and numbers only"
			echo "non alpha-numeric characters allowed:"
			echo " - dash (-)"
			echo " - underscore (_)"
			echo " - dot (.)"
			echo " ^ these cannot be first or last"
			echo " ^ cannot be repeated (eg --)"
			echo
			echo "------SELECTED SOURCE DESCRIPTION------------"
			_readKey c/${2}/self.description
		}
		# export function to fzf for --preview
		export -f _validateName
		local _fzfFalse="fzf --bind=enter:print-query --print-query --exact "
		local _fzfPrompt="--prompt=TYPE-NEW-NAME> --info=hidden"
		local _fzfColor="--color=bg:#222222,preview-bg:#333333,header:yellow"
		local _fzfHeader="--header=existing above, guidance right >"
		local _fzfPreview="--preview=_validateName {q} {} --preview-window=50%"
		local _fzfBack="--bind=backward-eof:change-prompt(ENTER-NEW-NAME>)"
		local _fzfEsc="--bind=esc:clear-query"
		_doesKeyExist c/* || local _fzfSeed="--query=sample"
		# this fzf command allows us to use as a "reverse" or false finder...ie we
		# use the fzf results to show a list from which we cannot choose one of the
		# already existing members of the list
		while true; do
			_newSourceName=$(_getSourceList | ${_fzfFalse} ${_fzfBack} ${_fzfEsc} ${_fzfPrompt} ${_fzfSeed:-} "${_fzfColor}" "${_fzfHeader}" "${_fzfPreview}")
			if _isSourceNameValid "${_newSourceName}"; then
				_prompt "'${_newSourceName}' is valid, create? (y/n/q) "
				read -r -s -n 1 _ynq
				[[ "${_ynq:-}" = "y" ]] && break
				[[ "${_ynq:-}" = "q" ]] && return
				[[ "${_ynq:-}" = "n" ]] && continue
			else
				_warn "'${_newSourceName}' is not a valid name"
				_prompt "try again? (y/n) "
				read -r -s -n1  _yn
				[[ "${_yn:-}" = "y" ]] && continue
				[[ "${_yn:-}" = "n" ]] && return
			fi
		done
		_prompt "enter a description for '${_newSourceName}': "
		while read -r -e  _newSourceDescription; do
			case "${_newSourceDescription}" in
				help|h|\?)
					_info "enter a description for '${_newSourceName}'"
					_info "example: little green notebook 12 Jan 2023" 
					_info "example: lecture notes from chem 202"
					_info "note: the description can be changed later"
					_info "    : multiple lines can be added later as well"
					_info "usage: q to abort, h for this help."
					_info "enter a description for '${_newSourceName}': "
					;;
				quit|q)
					_warn "aborting; '${_newSourceName}' not added. try again later"
					return
					;;
				*)
					[[ -z ${_newSourceDescription} ]] && _warn "empty description not allowed" && continue
					break
					;;
			esac
		done
		while read -r -e -n1 -p "${user}USER${reset} save '${_newSourceName}' as a new source? (y/n) " _c; do
			case ${_c} in
				y)
					_saveSource "${_newSourceName}" "${_newSourceDescription}"
					break
					;;
				n)
					return
					;;
				*)
					continue
					;;
			esac
		done
		while read -r -e -n1 -p "${user}USER${reset} set ${_newSourceName} as current? (y/n) " _d; do
			case ${_d} in
				y)
					_setSource "${_newSourceName}"
					return
					;;
				n)
					return
					;;
				*)
					continue
					;;
			esac
	done
	}
	_isSourceNameValid() {
		# arg 1 = source name
		if [[ "${1}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){3,${_maxLength}}$ ]]; then
			[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
			[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
			[[ "${1}" =~ ([.]|[-]|[_]){2} ]] && return 1
			if _isSourceNew "${1}"; then
				return 0
			else
				_warn "'${1}' is not new"
				return 1
			fi
		else
			_warn "'${1}' is not allowed, try again"
			_warn "rules: a-z A-Z 0-9 _ - allowed; no spaces allowed"
			_warn "rules: max length ${_maxLength} characters, min is 3"
			return 1
		fi
	}
# HEALTH CHECK for source
# 1. get name
# 2. get description
# 3. look for unused source
# 4. look for underutilized (possible consolidation)
# TODO consider adding a super-set (like binding old notebooks into one)
# TODO add delete, rename, merge, and split
	_mainMenu
}

###############
###### SHELL
###############

# TODO add trap to commit changes when shell exits (ie commit a session)

_shell() {
	# enter (cd) into studio environment
	# change the command history file
	# change the prompt dynamically
	cd "${_studioDir}" || _log 4 "can not enter studio"
	HISTFILE="${_studioDir}/.germ_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _prompt
	local _dirty
	#trap _confirmExit EXIT
	# set prompt function
	_setPrompt() {
		_isIndexClean || _dirty="${boldred}X${reset}"
		_cs=$(_getSource)
		_prompt="${prompt}${_studioDirName}${reset}:${label}${_germDirName}${reset} ${green}${_user}${reset} [${_cs}] ${_dirty:-} > "
	}
	# confirm exit function
	_confirmExit() {
		_prompt "quit germ? press ${label}y${reset} to quit"
		while read -r -s -n 1  __confirm; do
			echo
			case ${__confirm} in
				y)
					_isIndexClean || _doCommit "[germ] $(date) closed session"
					exit 0
					;;
				*)
					_mainPrompt
					;;
			esac
		done
	}
	# print welcome function
	_displayWelcome() {
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

germ: type ${green}help${reset} for guidance
      type ${red}stop${reset} to leave

HEREDOC
	}
	# print usage
	_printShellUsage() {
		cat << EOF

  add        add a new germ entry
  list       list the tag catalog
  status     show germ health
  source     add and manipulate source
  stop       exit studio
  help       print this message

EOF
	}
	# main shell prompt function
	_mainPrompt() {
	_setPrompt
	# ignore ctrl+\ ctrl+z and ctrl+c
	trap '' SIGQUIT SIGTSTP SIGINT
	# catch ctrl-d and run _confirmExit
	#trap _confirmExit EXIT
	# THIS IS NOT WORKING RIGHT

	local __input
	#while IFS='' read -r -d $'\n' -p "${_prompt}" __input; do
	while IFS='' read -r -e -d $'\n' -p "${_prompt}" __input; do
	#while read -p -e -p "${_prompt}" __input; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			#_isIndexClean || _doCommit "[germ] $(date) closed session"
			trap - EXIT
			trap - SIGINT
			cd $OLDPWD; exit 0
		elif [[ "${__input}" =~ (^help$|^h$|^\?$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_listTags
		elif [[ "${__input}" =~ (^status$|^stat$) ]]; then
			_showStatus
			_isIndexClean || _log 3 "DIRTY INDEX"
		elif [[ "${__input}" =~ (^add$|^a$) ]]; then
			eval "${self}" add || true
		elif [[ "${__input}" =~ (^source$|^s$) ]]; then
			_source
		else
			eval "${self}" "${__input}" || :
		fi
		_setPrompt
	done
	}
	_displayWelcome
	_mainPrompt
}	

###########################
# trap and signal catching

_irishExit() {
  _warn "ctrl-c detected; to resume, press R, to quit, press ENTER"
  read -s -t 15 -n 1 _ANS
  if [[ ${_ANS:-n} = 'R' ]]; then
    return
		#_info "resuming"
  else
   	_log 4 "user requested exit with ctrl-c"
		exit 1
		#return 1
  fi
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
	_log 0 "${FUNCNAME[0]}: _subCommand: ${_subCommand:-}"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# setup the environment after processing all command line parameters
	_setEnv
	# validate the environment
	_isEnvSufficient || _log 4 "cannot run until these problems are resolved"
	# set the global _user var
	#_setUserUUID || _log 4 "cannot set the user hash string"
	# get and set the current source notebook
	#_currentSource=$(_getSource) 
	#_warn "current source= $_currentSource"
	# TODO move this to the approprite location...source only matters to germ
	# functions
	# run germ shell if no arguments
	# TODO figure out how to pipe input to germ without triggering the shell
	[ -z "${_subCommand:-}" ] && _shell
	# otherwise, pass the commands to the called "command"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}" || exit
}
main "${@}"
