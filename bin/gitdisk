#!/usr/bin/env bash
# file: gitdisk
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# bash strict settings
set -o errexit
set -o nounset
set -o pipefail

# debugging and logging settings
#set -x
# script debug toggle (set to true to enable global debugging)
_DEBUG=false
# silent mode for scripting (supresses stdout/stderr)
_SILENT=false
# logging facility
_LOG=true

# some color
red=$(tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
reset=$(tput sgr0)

# use "main" as the initial and main branch instead of deprecated indelicate "master"
_initialBranch="main"
# set the maximum length of a gitdisk (directory) name
_maxChar=25
# set the min length of a gitdisk (directory) name
_minChar=2

# store gitdisk state and logs in $HOME/.gitdisk
_gitdiskConfig=.gitdisk
_dotGitdisk="$(dirname ~/.)/${_gitdiskConfig}"
_logFile="${_dotGitdisk}/logs/gitdisk.log"

# logging and debug functions
_log() {
	# write logs to persistent logfile
	# FORMAT: timestamp [USER|INFO|DEBUG] "message"
	local _timeStamp
	_timeStamp=$(date +%s)
	local _logMessage="${*:-}"
	[ ${_LOG} = false ] && return
	[ -f "${_logFile}" ] || mkdir -p "${_dotGitdisk}/logs" && touch "${_logFile}"
	printf "%s %s\n" "${_timeStamp}" "${_logMessage}" >> "${_logFile}"
}

_debug() {
	# write debug info to stdout and/or log
	local _debugMessage="${*:-}"
	# if debug is not enabled, ignore and return
	[ ${_DEBUG} = false ] && return
	# if debug is true and _SILENT is not true, print debug to terminal
	if [ ${_DEBUG} = true ] && [ ! ${_SILENT} = true ]; then
		echo "${cyan}DEBUG${reset}: ${_debugMessage}"
	fi
	# send to log facility
	_log DEBUG "${_debugMessage}"
}

# die verbally
_fatal() {
	echo "FATAL: $*"
	exit 1
}

_isGitReady() {
	# check that our version of git supports this (git >= 2.28)
	if ! hash git; then
		_debug "ERROR: _isGitReady(): git is required"
		exit 1
	else
		_gitVersion=$(git --version | cut -d' ' -f3)
		_debug "INFO: _isGitReady(): git version is ${_gitVersion}"
		_gitMajor=$(echo "${_gitVersion}" | cut -d. -f1)
		_gitMinor=$(echo "${_gitVersion}" | cut -d. -f2)
		if [ "${_gitMajor}" -eq 2 ] && [ "${_gitMinor}" -ge 28 ]; then
			_debug "INFO: _isGitReady(): git version ${_gitVersion} is >= 2.28"
			return 0
		else
			_debug "ERROR: _isGitReady(): git version ${_gitVersion} is not >= 2.28"
			_debug "INFO: _isGitReady(): upgrade git to 2.28 or later to use gitdisk"
			exit 1
		fi
	fi
}

_printUsage () {
  cat << EOF

usage: gitdisk [OPTIONS] command [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 create              create a local gitdisk
 mirror              attach a mirror repo
 import              import a remote gitdisk
 sync                sync to remote(s)
 put                 add a new item to gitdisk
 get                 retrieve an object

for command specific usage, eg:
$ gitdisk create help

EOF
}

printInfo () {
  cat << EOF

gitdisk treats a git repo like a disk database.  it is meant
for a single-user multi-session git repo, whether as a code 
or document repository.  it is mainly a wrapper for setting
up git repos and attaching remotes for redundancy.  it is not
meant for regular users but as a back-end "disk" setup and 
low-level gitdisk read and write command.

EOF
}

_isNameValid() {
	# _isNameValid: check for allowed names
	# arg = name
	# return 0 (yes) if valid, 1 (no) if invalid
	# legal name: max char = 25, min=2
	#             a-z 0-9 - .
	#             first and last not - or .
	#							no double dash or dot
	#							no dash follows dot and vice versa
	local _requestedName="${*}"
	local _strLength=${#_requestedName}
	_debug "INFO: _isNameValid(): requestedName=${_requestedName}"
	_debug "INFO: _isNameValid(): strLength=${#_requestedName}"
	# check first char first...must be lowercase or number	
	if [[ ! ${_requestedName} =~ ^[[:lower:]|[:digit:]] ]]; then
			_debug "ERROR: _isNameValid(): first char must be letter or digit"
			return 1
	# check string length
	#elif [ "${_strLength}" -lt ${_minChar} -o "${_strLength}" -gt ${_maxChar} ]; then
	elif [ "${_strLength}" -lt ${_minChar} ] || [ "${_strLength}" -gt ${_maxChar} ]; then
		_debug "ERROR: _isNameValid(): length violation"
		return 1
	# check last char...must be lower or number
	elif [[ ! ${_requestedName} =~ [[:lower:]|[:digit:]]$ ]]; then
			_debug "ERROR: _isNameValid(): last char must be letter or digit"
			return 1
	# check for allowed characters
	elif [[ ! ${_requestedName} =~ ^([[:lower:]|[:digit:]]|[-.])*$ ]]; then
			_debug "ERROR: _isNameValid(): only lower, digit, hyphen and period allowed"
			return 1
	else
		# check for other conditions we deem illegal
		case ${_requestedName} in
			*--* ) _debug "ERROR: _isNameValid(): double dash"; return 1 ;;
			*..* ) _debug "ERROR: _isNameValid(): double dot"; return 1 ;;
			*.-* ) _debug "ERROR: _isNameValid(): dash follows dot"; return 1 ;;
			*-.* ) _debug "ERROR: _isNameValid(): dot follows dash"; return 1 ;;
		esac
	fi
}

# _setDesiredPath: take path arg and set name and path variables
_setDesiredPath() {
	# read $1
	# set _desiredPath and _desiredName and _desiredBase
	if [ -z "${1}" ]; then
		_debug "ERROR: _setDesiredPath requires an argument"
		return 1
	else
			local _workDir
			_workDir="$(pwd)"
			_debug "INFO: _setDesiredPath(): workDir=${_workDir}"
			# figure out the path; full or relative path allowed
			if [[ "${1}" = /* ]]; then
				_desiredPath="${1}"
				_desiredName=$(basename "${1}")
			elif [[ "${1}" = ..* ]]; then
        _debug "ERROR: _setDesiredPath(): no path redirects"; exit 1
      elif [[ "${1}" = ./* ]]; then
        _debug "INFO: _setDesiredPath(): fix this into relative path, strip 1st 2 chars"; exit 1
				# TODO fix this in case path is explicitly relative
      elif [[ "${1}" = . ]]; then
				_desiredPath="${_workDir}"
				_desiredName=$(basename "${_workDir}")
			else
				_desiredPath="${_workDir}/${1}"
				_desiredName=${1}
			fi
			_desiredBase=$(dirname "${_desiredPath}")
			_debug "INFO: _setDesiredPath(): desired path is '${_desiredPath}'"
			_debug "INFO: _setDesiredPath(): desired name is '${_desiredName}'"
			_debug "INFO: _setDesiredPath(): desired base is '${_desiredBase}'"
			# TODO make sure to always strip off trailing slash
	fi
}

# _isPathWritable: take path arg and determine if we can write
_isPathWritable() {
	# arg 1 = full path
	# return 0 (yes) if writable, 1 (no) if not writable
	if [ -z "${1}" ]; then
		_debug "ERROR: _isPathWritable requires an argument"
		return 1
	elif [ ! -w "${1}" ]; then
		_debug "ERROR: ${1} is not writable"
		return 1
	fi	
}

# _isPathEmpty: return 0 if path contains no files
_isPathEmpty() {
	# arg 1 = full path
	# return 0 if empty, return 1 if not empty
	if [ -z "${1}" ]; then
		_debug "ERROR: _isPathEmpty requires an argument"
		return 1
	elif [ -n "$(ls -A "${1}" 2>/dev/null)" ]; then
		_debug "WARNING: _isPathEmpty(): ${1} is NOT empty"
		return 1
	fi
}

# _isPathNew: check if path already exists or not
_isPathNew() {
	# arg 1 = full path
	# return 0 if new; return 1 if exists 
	if [ -z "${1}" ]; then
		_debug "ERROR: _isPathNew requires an argument"
		return 1
	elif [ -d "${1}" ]; then
		_debug "WARNING: _isPathNew(): ${1} exists"
		return 1
	fi
}

# _isPathGitdisk: check for existence of gitdisk
_isPathGitdisk() {
	# arg 1 = full path
	# return 0 if gitdisk, return 1 if not
	if [ -z "${1}" ]; then
		_debug "ERROR: _isPathGitdisk requires an argument"
		return 1
	elif [[ ! -d "${1}/.git" ]]; then
		return 1
	else
		_debug "ERROR: .git exists in ${1}"
		# TODO add check for gitdisk marker
		return 0
	fi
}

# _createGitdisk: git init _desiredPath
_createGitdisk() {
	# arg 1 = full path
	# return 0 on success, 1 on fail
	local _uuidMark
	local _timestampUnix
	_uuidMark=$(uuidgen | tr "[:upper:]" "[:lower:]")
	_timestampUnix=$(date +%s)
	local _gitdiskSignature="gitdisk: $USER $HOSTNAME ${_timestampUnix} ${_uuidMark}"
	if [ -z "${1}" ]; then
		_debug "ERROR: _createGitdisk requires an argument"
		return 1
	else
		git init -q -b "${_initialBranch}" "${1}" || _log "ERROR: _createGitdisk(): create failed: err?: $?"
		echo "${_gitdiskSignature}" > "${1}/.git/description"
		# this will become a gitdisk.tab file (a la fstab)
		# fields
		# uuid path user hostname timestamp
		echo "${_uuidMark} ${1} $USER $HOSTNAME ${_timestampUnix}" >> ~/.gitdisk/gitdisk.tab
		_log "INFO: _createGitdisk(): created ${_uuidMark} at ${1} by $USER on $HOSTNAME"
	fi
}

_getOpts () {
	# check for global command flags and set VARS accordingly
	_debug "INFO: _getOpts(): positional parameters read: $*"
	local OPTIND
	while getopts ":hsdlv" flag ; do
		#_debug "INFO: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				printInfo ; _printUsage; exit 0
				;;
 	    s)
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				;;
			l)
				_LOG=true
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*

	_debug "INFO: _LOG=${_LOG}"
	_debug "INFO: _SILENT=${_SILENT}"
	_debug "INFO: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_debug "INFO: _getSubcommand(): reading parameter '${1}'"
		case $1 in
			create)
				_debug "INFO: _getSubcommand(): '$1' called, check for create flags"
				_subCommand=$1
				_getCreateOpts
				return
				;;
			help)
				echo "check for command '${2:-}' and print help if it exists"
				exit 0
				;;
			init)
				_debug "INFO: _getSubcommand(): '$1' called, check for init flags"
				_subCommand=$1
				return
				;;
			*)
				_debug "ERROR: _getSubcommand(): $1 is not a subcommand"
				exit 1
				;;
		esac
		shift
	done
}	

_getCreateOpts() {
	# check for create flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_debug "INFO: _getCreateOpts(): positional parameters read: $*"
	shift
	while getopts ":fo:" flag "$@" ; do
		case ${flag} in 
			f)
				_forceCreate=true
				_debug "INFO: _getCreateOpts(): force mode is enabled"
				;;
			o)
				_debug "INFO: _getCreateOpts(): setting option _createObjectHold=$OPTARG"
				_createObjectHold=$OPTARG
				;;
			?)
				echo "${red}ERROR${reset}: invalid option: -$OPTARG"; exit 1
				_debug "INFO: _getCreateOpts(): unknown flag: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_create() {
	local _desiredPath=$_workingParams
	if [ ! -d ~/.gitdisk ]; then
		echo "${red}ERROR${reset}: run 'gitdisk init' first"
		exit 1
	fi
	if [[ -z "${_desiredPath:-}" ]]; then
		echo "${red}ERROR${reset}: usage: gitdisk create <name>"
		echo "       <name> must be a full path or relative to PWD"
		exit 1
	else _setDesiredPath "${_desiredPath}"
	fi
	if _isNameValid "${_desiredName}"; then
		_debug "INFO: _create(): '${_desiredName}' is a valid name"
	else
		[ -z "${_verbose:-}" ] || echo "${red}ERROR${reset}: invalid name"
		_debug "ERROR: _create(): '${_desiredName}' is an invalid name"
		exit 1
	fi
	if _isPathNew "${_desiredPath}"; then
		_debug "INFO: _create(): '${_desiredPath}' is new"
		if _isPathWritable "${_desiredBase}"; then
			_debug "INFO: _create(): '${_desiredPath}' is writable"
		else
			_debug "ERROR: _create(): '${_desiredBase}' is not writable"
			exit 1
		fi
	else
		if _isPathEmpty "${_desiredPath}"; then
			_debug "INFO: _create(): '${_desiredPath}' is empty"
		else
			if _isPathGitdisk "${_desiredPath}"; then
				_signature=$(cat "${_desiredPath}/.git/description")
				_debug "WARNING: _create(): '${_desiredPath}' is a gitdisk: ${_signature}"
				echo "${red}ERROR${reset}: could not create due to existing gitdisk"
				exit 1
			else
				_debug "WARNING: _create(): '${_desiredPath}' is not empty and is not a gitdisk"
				echo "${red}ERROR${reset}: could not create due to non-empty path"
				exit 1
			fi
		fi
	fi
	_debug "INFO: _create(): all conditions passed...creating gitdisk..."
	if _createGitdisk "${_desiredPath}"; then
		_debug "INFO: _create(): gitdisk created at ${_desiredPath}"
	else
		_debug "ERROR: _create(): gitdisk failed to create ${_desiredPath}"
		exit 1
	fi
}

# mirror              attach a mirror repo
# import              import a remote gitdisk
# sync                sync to remote(s)
# new                 add a new item to gitdisk
# mv                  move item within gitdisk
# rm                  remove item from gitdisk
# open                open item

_init() {
	# set up ~/.gitdisk and gitdisktab
	if [ -f "${_dotGitdisk}/.installed" ]; then
		_debug "ERROR: gitdisk already installed"
		echo "${red}ERROR${reset}: gitdisk already installed"
		exit 1
	else
		_createGitdisk "${_dotGitdisk}"
		echo "logs/" >> "${_dotGitdisk}/.gitignore"
		[ ! -d "${_dotGitdisk}/logs" ] && mkdir "${_dotGitdisk}/logs"
		touch "${_dotGitdisk}/gitdisk.tab"
		touch "${_dotGitdisk}/.installed"
		_debug "INFO: ${_dotGitdisk} created...gitdisk ready to use"
	fi	
}

_checkSelf() {
	# check if installed
	if [ "${_subCommand}" = "init" ] && [ ! -d "${_dotGitdisk}" ]; then
		return 0
	else [ -d "${_dotGitdisk}" ] && return 0 || return 1
	fi
}

main() {
	_getOpts "${@}"
	_debug "INFO: _main(): origParams: $*"
	_debug "INFO: _main(): pairedParams: $_workingParams"
	_getSubcommand $_workingParams
	_debug "INFO: _main(): _subCommand: $_subCommand"
	_debug "INFO: _main(): remaining arg: $_workingParams"
	_isGitReady
	_checkSelf || _fatal "ERROR: no .gitdisk dir; run 'gitdisk init' first"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"
