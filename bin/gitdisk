#!/usr/bin/env bash
# file: gitdisk
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# bash strict settings
set -o errexit
set -o nounset
set -o pipefail

# bash debugging
#set -x

# some color
red=$(tput setaf 1)
green=$(tput setaf 2)
reset=$(tput sgr0)


# use "main" as the initial and main branch instead of deprecated "master"
_initialBranch="main"
# set the maximum length of a gitdisk (directory) name
_maxChar=25
# set the min length of a gitdisk (directory) name
_minChar=2

# check that our version of git supports this (git >= 2.28)
if ! hash git; then
	echo "ERROR: git is required"
	exit 1
else
	_gitVersion=$(git --version | cut -d' ' -f3)
	echo "DEBUG: git version is ${_gitVersion}"
	_gitMajor=$(echo ${_gitVersion} | cut -d. -f1)
	_gitMinor=$(echo ${_gitVersion} | cut -d. -f2)
	if [ ${_gitMajor} -eq 2 ] && [ ${_gitMinor} -ge 28 ]; then
		echo "DEBUG: OK: git version ${_gitVersion} is >= 2.28"
	else
		echo "ERROR: git version ${_gitVersion} is not >= 2.28"
		echo "       upgrade git to 2.28 or later to proceed with gitdisk"
		exit 1
	fi
fi

# FUNCTIONS
printUsage () {
  cat << EOF

usage: gitdisk [OPTIONS] command [OPTIONS]

options:
 -h(elp)             print this usage page
 -l(og)              log to logfile
 -v(ersion)          print version

commands:
 create              create a local gitdisk
 mirror              attach a mirror repo
 import              import a remote gitdisk
 sync                sync to remote(s)
 new                 add a new item to gitdisk
 mv                  move item within gitdisk
 rm                  remove item from gitdisk
 open                open item

for command specific usage, eg:
$ gitdisk create help

EOF
}

printInfo () {
  cat << EOF

gitdisk treats a git repo like a disk database.  it is meant
for a single-user multi-session git repo, whether as a code 
or document repository.  it is mainly a wrapper for setting
up git repos and attaching remotes for redundancy.  it is not
meant for regular users but as a back-end "disk" setup and 
low-level gitdisk read and write command.

EOF
}

_isNameValid() {
	# arg = name
	# return 0 if legal, 1 if illegal
	# legal name: max char = 25, min=2
	#             a-z 0-9 - .
	#             first and last not - or .
	#							no double dash or dot
	#							no dash follows dot and vice versa
	local _requestedName="${@}"
	local _strLength=${#_requestedName}
	echo "DEBUG: _requestedName=${_requestedName}"
	echo "DEBUG: _strLength=${#_requestedName}"
	# check first char first...must be lowercase or number	
	if [[ ! ${_requestedName} =~ ^[[:lower:]|[:digit:]] ]]; then
			echo "${red}INVALID${reset}: first char must be letter or digit"
			return 1
	# check string length
	elif [ ${_strLength} -lt ${_minChar} -o ${_strLength} -gt ${_maxChar} ]; then
		echo "${red}INVALID${reset}: length violation"
		return 1
	# check last char...must be lower or number
	elif [[ ! ${_requestedName} =~ [[:lower:]|[:digit:]]$ ]]; then
			echo "${red}INVALID${reset}: last char must be letter or digit"
			return 1
	# check for allowed characters
	elif [[ ! ${_requestedName} =~ ^([[:lower:]|[:digit:]]|[-.])*$ ]]; then
			echo "${red}INVALID${reset}: only lower, digit, hyphen and period allowed"
			return 1
	else
		# check for other conditions we deem illegal
		case ${_requestedName} in
			*--* ) echo "${red}INVALID${reset}: double dash"; return 1 ;;
			*..* ) echo "${red}INVALID${reset}: double dot"; return 1 ;;
			*.-* ) echo "${red}INVALID${reset}: dash follows dot"; return 1 ;;
			*-.* ) echo "${red}INVALID${reset}: dot follows dash"; return 1 ;;
		esac
	fi
}

_setDesiredPath() {
	# read $1
	# export _desiredPath and _desiredName
	if [ -z "${1}" ]; then
		echo "DEBUG: _setDesiredPath requires an argument"
		return 1
	else
			local _workDir="$(pwd)"
			echo "DEBUG: cmd called: $@"
			echo "DEBUG: _LOG=${_LOG:-}"
			echo "DEBUG: _workDir=${_workDir}"
			# figure out the path; full or relative path allowed
			if [[ "${1}" = /* ]]; then
				_desiredPath="${1}"
				_desiredName=$(basename "${1}")
			elif [[ "${1}" = ..* ]]; then
        echo "${red}ERR${reset} no path redirects"; exit 1
      elif [[ "${1}" = ./* ]]; then
        echo "${red}ERR${reset}: fix this into relative path, strip 1st 2 chars"; exit 1
      elif [[ "${1}" = . ]]; then
				_desiredPath="${_workDir}"
				_desiredName=$(basename "${_workDir}")
			else
				_desiredPath="${_workDir}/${1}"
				_desiredName=${1}
			fi
			echo "DEBUG: desired path is '${_desiredPath}'"
			echo "DEBUG: desired name is '${_desiredName}'"
	fi
}

_isPathWritable() {
	# arg 1 = full path
	# return 0 if writable and no .git dir (existing gitdisk)
	# if writable and empty
	set -x
	if [ -z "${1}" ]; then
		echo "DEBUG: _isPathWritable requires an argument"
		return 1
	elif [[ -d "${1}/.git" ]]; then
		echo "${red}ERROR${reset}: .git exists in ${1}"; exit 1
	elif [[ -w "${1}" ]]; then
		return 0
	fi
}

# TODO functions for create
# _isNameValid: check for allowed names
# _isPathEmpty: check for existing (or not)
# _isPathWritable: check permissions
# _createGitdisk: git init _desiredPath

# command line processing
_getOpts () {
	# check for global command flags
	while getopts ":hvl" flag ; do
		local OPTIND
		case ${flag} in 
			h)
				printInfo ; printUsage; exit 0
				;;
 	    v)
 	      echo "VERSION: betaitch"; exit 0
				;;
			l)
				export _LOG=true
				;;
		esac
	done
	shift $((OPTIND -1))

	# (sub)command option processing
	case "${1:-}" in
		create)
			# create              create a local gitdisk
			# usage: create <name> where <name> is a full or relative path to PWD
			if [[ -z "${2:-}" ]]; then
				echo "${red}ERROR${reset}: usage: gitdisk create <name>"
				echo "       <name> must be a full path or relative to PWD"
				exit 1
			else _setDesiredPath "${2}"
			fi
			if ! _isNameValid ${_desiredName}; then
				echo "${red}ERROR${reset}: invalid name"; exit 1
			fi
			if _isPathWritable "${_desiredPath}"; then
				echo "${green}YES${reset}: ${_desiredPath} is writable"
				exit 0
			fi
			exit 
			# if writable and empty
			if [[ -w $(dirname "${_desiredPath}") ]] && [[ ! -d "${_desiredPath}" ]]; then
				echo "OK: path is writable and empty"
				if git init -q -b "${_initialBranch}" "${_desiredPath}"; then
					echo "OK: created gitdisk as ${_desiredPath}"
				fi
			# if not writable
			elif [[ ! -w "${_desiredPath}" ]]; then
				echo "ERROR: path ${_desiredPath} is not writable"; exit 1
			else
				echo "ERROR: path ${_desiredPath} is not empty"; exit 1
			fi	
			;;
		mirror)
			# mirror              attach a mirror repo
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		import)
			# import              import a remote gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		sync)
			# sync                sync to remote(s)
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		new)
			# new                 add a new item to gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		mv)
			# mv                  move item within gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		rm)
			# rm                  remove item from gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		open)
			# open                open item
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		*)
			printUsage
			exit 1
			;;
	esac
}

main() {
	_getOpts "${@}"
	return 0
}
main "${@}"

