#!/usr/bin/env bash
# file: gitdisk
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# bash strict settings
set -o errexit
set -o nounset
set -o pipefail

# bash debugging
#set -x

# some color
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
reset=$(tput sgr0)


# use "main" as the initial and main branch instead of deprecated "master"
_initialBranch="main"
# set the maximum length of a gitdisk (directory) name
_maxChar=25
# set the min length of a gitdisk (directory) name
_minChar=2

_gitdiskConfig=$(dirname ~/.)
_gitdiskConfig+="/.gitdisk"

# check that our version of git supports this (git >= 2.28)
if ! hash git; then
	echo "ERROR: git is required"
	exit 1
else
	_gitVersion=$(git --version | cut -d' ' -f3)
	echo "DEBUG: git version is ${_gitVersion}"
	_gitMajor=$(echo ${_gitVersion} | cut -d. -f1)
	_gitMinor=$(echo ${_gitVersion} | cut -d. -f2)
	if [ ${_gitMajor} -eq 2 ] && [ ${_gitMinor} -ge 28 ]; then
		echo "DEBUG: OK: git version ${_gitVersion} is >= 2.28"
	else
		echo "ERROR: git version ${_gitVersion} is not >= 2.28"
		echo "       upgrade git to 2.28 or later to proceed with gitdisk"
		exit 1
	fi
fi

# FUNCTIONS
printUsage () {
  cat << EOF

usage: gitdisk [OPTIONS] command [OPTIONS]

options:
 -h(elp)             print this usage page
 -l(og)              log to logfile
 -v(ersion)          print version

commands:
 create              create a local gitdisk
 mirror              attach a mirror repo
 import              import a remote gitdisk
 sync                sync to remote(s)
 new                 add a new item to gitdisk
 mv                  move item within gitdisk
 rm                  remove item from gitdisk
 open                open item

for command specific usage, eg:
$ gitdisk create help

EOF
}

printInfo () {
  cat << EOF

gitdisk treats a git repo like a disk database.  it is meant
for a single-user multi-session git repo, whether as a code 
or document repository.  it is mainly a wrapper for setting
up git repos and attaching remotes for redundancy.  it is not
meant for regular users but as a back-end "disk" setup and 
low-level gitdisk read and write command.

EOF
}

# _isNameValid: check for allowed names
_isNameValid() {
	# arg = name
	# return 0 (yes) if valid, 1 (no) if invalid
	# legal name: max char = 25, min=2
	#             a-z 0-9 - .
	#             first and last not - or .
	#							no double dash or dot
	#							no dash follows dot and vice versa
	local _requestedName="${@}"
	local _strLength=${#_requestedName}
	echo "DEBUG: _requestedName=${_requestedName}"
	echo "DEBUG: _strLength=${#_requestedName}"
	# check first char first...must be lowercase or number	
	if [[ ! ${_requestedName} =~ ^[[:lower:]|[:digit:]] ]]; then
			echo "${red}INVALID${reset}: first char must be letter or digit"
			return 1
	# check string length
	elif [ ${_strLength} -lt ${_minChar} -o ${_strLength} -gt ${_maxChar} ]; then
		echo "${red}INVALID${reset}: length violation"
		return 1
	# check last char...must be lower or number
	elif [[ ! ${_requestedName} =~ [[:lower:]|[:digit:]]$ ]]; then
			echo "${red}INVALID${reset}: last char must be letter or digit"
			return 1
	# check for allowed characters
	elif [[ ! ${_requestedName} =~ ^([[:lower:]|[:digit:]]|[-.])*$ ]]; then
			echo "${red}INVALID${reset}: only lower, digit, hyphen and period allowed"
			return 1
	else
		# check for other conditions we deem illegal
		case ${_requestedName} in
			*--* ) echo "${red}INVALID${reset}: double dash"; return 1 ;;
			*..* ) echo "${red}INVALID${reset}: double dot"; return 1 ;;
			*.-* ) echo "${red}INVALID${reset}: dash follows dot"; return 1 ;;
			*-.* ) echo "${red}INVALID${reset}: dot follows dash"; return 1 ;;
		esac
	fi
}

# _setDesiredPath: take path arg and set name and path variables
_setDesiredPath() {
	# read $1
	# set _desiredPath and _desiredName and _desiredBase
	if [ -z "${1}" ]; then
		echo "DEBUG: _setDesiredPath requires an argument"
		return 1
	else
			local _workDir="$(pwd)"
			echo "DEBUG: _workDir=${_workDir}"
			# figure out the path; full or relative path allowed
			if [[ "${1}" = /* ]]; then
				_desiredPath="${1}"
				_desiredName=$(basename "${1}")
			elif [[ "${1}" = ..* ]]; then
        echo "${red}ERR${reset} no path redirects"; exit 1
      elif [[ "${1}" = ./* ]]; then
        echo "${red}ERR${reset}: fix this into relative path, strip 1st 2 chars"; exit 1
				# TODO fix this in case path is explicitly relative
      elif [[ "${1}" = . ]]; then
				_desiredPath="${_workDir}"
				_desiredName=$(basename "${_workDir}")
			else
				_desiredPath="${_workDir}/${1}"
				_desiredName=${1}
			fi
			_desiredBase=$(dirname "${_desiredPath}")
			echo "DEBUG: desired path is '${_desiredPath}'"
			echo "DEBUG: desired name is '${_desiredName}'"
			echo "DEBUG: desired base is '${_desiredBase}'"
			# TODO make sure to always strip off trailing slash
	fi
}

# _isPathWritable: take path arg and determine if we can write
_isPathWritable() {
	# arg 1 = full path
	# return 0 (yes) if writable, 1 (no) if not writable
	if [ -z "${1}" ]; then
		echo "DEBUG: _isPathWritable requires an argument"
		return 1
	elif [ ! -w "${1}" ]; then
		#echo "DEBUG: ${1} is not writable"
		return 1
	fi	
}

# _isPathEmpty: return 0 if path contains no files
_isPathEmpty() {
	# arg 1 = full path
	# return 0 if empty, return 1 if not empty
	if [ -z "${1}" ]; then
		echo "DEBUG: _isPathEmpty requires an argument"
		return 1
	elif [ ! -z "$(ls -A ${1} 2>/dev/null)" ]; then
		#echo "DEBUG: $?: ${1} is NOT empty"
		return 1
	fi
}

# _isPathNew: check if path already exists or not
_isPathNew() {
	# arg 1 = full path
	# return 0 if new; return 1 if exists 
	if [ -z "${1}" ]; then
		echo "DEBUG: _isPathNew requires an argument"
		return 1
	elif [ -d "${1}" ]; then
		#echo "DEBUG: ${1} exists"
		return 1
	fi
}

# _isPathGitdisk: check for existence of gitdisk
_isPathGitdisk() {
	# arg 1 = full path
	# return 0 if gitdisk, return 1 if not
	if [ -z "${1}" ]; then
		echo "DEBUG: _isPathGitdisk requires an argument"
		return 1
	elif [[ ! -d "${1}/.git" ]]; then
		return 1
	else
		#echo "DEBUG: .git exists in ${1}"
		# TODO add check for gitdisk marker
		return 0
	fi
}

# _createGitdisk: git init _desiredPath
_createGitdisk() {
	# arg 1 = full path
	# return 0 on success, 1 on fail
	local _uuidMark=$(uuidgen | tr "[:upper:]" "[:lower:]")
	local _timestampUnix=$(date +%s)
	local _gitdiskSignature="gitdisk: $USER $HOSTNAME ${_timestampUnix} ${_uuidMark}"
	if [ -z "${1}" ]; then
		echo "DEBUG: _createGitdisk requires an argument"
		return 1
	else
		git init -q -b "${_initialBranch}" "${1}"
		echo "${_gitdiskSignature}" > "${1}/.git/description"
		# this will become a gitdisk.tab file (a la fstab)
		# fields
		# uuid path user hostname timestamp
		echo "${_uuidMark} ${1} $USER $HOSTNAME ${_timestampUnix}" >> ~/.gitdisk/gitdisk.tab
	fi
}

# command line processing
_getOpts () {
	# check for global command flags
	while getopts ":hvl" flag ; do
		local OPTIND
		case ${flag} in 
			h)
				printInfo ; printUsage; exit 0
				;;
 	    v)
 	      echo "VERSION: betaitch"; exit 0
				;;
			l)
				_LOG=true
				;;
		esac
	done
	shift $((OPTIND -1))

	# (sub)command option processing
	case "${1:-}" in
		create)
			# create              create a local gitdisk
			# usage: create <name> where <name> is a full or relative path to PWD
			# TODO add --forceNonempty and --forceGitdisk to override
			#      add --type=hidden to allow dot prefix eg "dot gitdisk" eg .hidden
			echo "DEBUG: cmd called: $@"
			echo "DEBUG: _LOG=${_LOG:-}"
			echo "DEBUG: _forceNonempty=${_forceNonempty:-}"
			if [ ! -d ~/.gitdisk ]; then
				echo "${red}ERROR${reset}: run 'gitdisk init' first"
				exit 1
			fi
			if [[ -z "${2:-}" ]]; then
				echo "${red}ERROR${reset}: usage: gitdisk create <name>"
				echo "       <name> must be a full path or relative to PWD"
				exit 1
			else _setDesiredPath "${2}"
			fi
			if _isNameValid ${_desiredName}; then
				echo "${green}OK${reset}: ${_desiredName} is a valid name"
			else
				echo "${red}ERROR${reset}: invalid name"
				exit 1
			fi
			if _isPathNew "${_desiredPath}"; then
				echo "${green}OK${reset}: ${_desiredPath} is new"
				if _isPathWritable "${_desiredBase}"; then
					echo "${green}OK${reset}: ${_desiredBase} is writable"
				else
					echo "${red}ERROR${reset}: ${_desiredBase} is not writable"
					exit 1
				fi
			else
				echo "${yellow}WARNING${reset}: ${_desiredPath} already exists"
				if _isPathEmpty "${_desiredPath}"; then
					echo "${green}OK${reset}: ${_desiredPath} is empty"
				else
					if _isPathGitdisk "${_desiredPath}"; then
						_signature=$(cat "${_desiredPath}/.git/description")
						echo "${yellow}WARNING${reset}: ${_desiredPath} is a gitdisk"
						echo "${yellow}INFO${reset}: ${_signature}"
						echo "${yellow}TODO${reset}: add force flag to re-initialize gitdisk"
						echo "${red}ERROR${reset}: could not create due to existing gitdisk"
						exit 1
					else
						echo "${yellow}WARNING${reset}: ${_desiredPath} is not empty"
						echo "${yellow}TODO${reset}: add force flag to add non-empty dir"
						echo "${red}ERROR${reset}: could not create due to non-empty path"
						exit 1
					fi
				fi
			fi
			echo "${green}OK${reset}: all conditions passed...creating gitdisk"
			if _createGitdisk "${_desiredPath}"; then
				echo "${green}OK${reset}: gitdisk created at ${_desiredPath}"
			else
				echo "${red}ERROR${reset}: gitdisk failed to create ${_desiredPath}"
				exit 1
			fi
			;;
		init)
			# set up ~/.gitdisk and gitdisktab
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			if [ -d "${_gitdiskConfig}" ]; then
				echo "${red}ERROR${reset}: gitdisk already installed"
				exit 1
			else
				_createGitdisk "${_gitdiskConfig}"
				echo "logs/" >> "${_gitdiskConfig}/.gitignore"
				mkdir "${_gitdiskConfig}/logs"
				touch "${_gitdiskConfig}/gitdisk.tab"
			fi	
			;;	
		mirror)
			# mirror              attach a mirror repo
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		import)
			# import              import a remote gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		sync)
			# sync                sync to remote(s)
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		new)
			# new                 add a new item to gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		mv)
			# mv                  move item within gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		rm)
			# rm                  remove item from gitdisk
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		open)
			# open                open item
			echo "cmd called: $@"
			echo "_LOG=${_LOG:-}"
			exit 0
			;;
		*)
			printUsage
			exit 1
			;;
	esac
}

main() {
	_getOpts "${@}"
	return 0
}
main "${@}"

