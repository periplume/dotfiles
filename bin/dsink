#!/usr/bin/env bash
# file: dsink
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# TO MY FUTURE SELF
# WHOSE MEMORY WILL STRUGGLE TO REMEMBER HOW THIS THING WORKS
# TOC MORE OR LESS:
# SCRIPT AND SHELL SETTINGS
# ENVIRONMENT SETTINGS
# DEFAULTS
# BASIC LOGGING FUNCTIONS
# HELPER FUNCTIONS
# PARAMETER PROCESSING FUNCTIONS
# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
# MAIN ENTRY AND CONTROL

# SCRIPT AND SHELL SETTINGS

# bash makin-it-hard settings
set -o errexit
set -o nounset
set -o pipefail
#set -x

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(rsync cryptsetup lsblk parted)

# ENVIRONMENT SETTINGS

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=true
# silent mode for scripting (supresses stdout/stderr)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=true

# some color
red=$(tput setaf 1)
boldred=$(tput bold; tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
reset=$(tput sgr0)

# DEFAULT SETTINGS

# store dsink state and logs in $HOME/dsink
_dsinkDirName=dsink
_dsinkDir="$(dirname ~/.)/${_dsinkDirName}"
_dsinkConf="${_dsinkDir}/dsink.conf"
_logFile="${_dsinkDir}/dsink.log"
_dsinkCatalog="${_dsinkDir}/dsink.catalog"
_dsinkMount="${_dsinkDir}/media"

# LOGGING 

_log() {
	# levels
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true
	# set to 0 to force all logs into DEBUG pipe
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	local _canLog=false
	# set timestamp for log message (unix seconds)
	local _timeStamp
	_timeStamp=$(date +%s)
	# define log levels and colors
	declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	local _level=${_i[${_logLevel}]}
	local _color=${_c[${_logLevel}]}
	# check if a logfile exists
	[ -f "${_logFile}" ] && _canLog=true
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	[ ${_SILENT} = true ] && return
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: ${_logMessage}" && exit 1
	fi
}

# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: dsink [OPTIONS] command [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 backup              synchronize defined local contents to mounted usb
 restore             reverse synchronize from usb to local device
 format              format a new usb portable device
 mount               open and mount usb device
 unmount             unmount and close usb device
 status              report on replication level status
 report              full report on replication level and media catalog

for command specific usage, eg:
$ dsink help backup

EOF
}

_printInfo () {
  cat << EOF

dsink maintains data replication of local data onto removable
usb devices which it encrypts (with luks).

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlv" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 1 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 1 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 1 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			backup)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for backup flags now"
				_subCommand=$1
				_getBackupOpts
				return
				;;
			restore)
				_log 0 "_getSubcommand(): '$1' called, check for restore flags"
				_subCommand=$1
				return
				;;
			format)
				_log 0 "_getSubcommand(): '$1' called, check for format flags"
				_subCommand=$1
				# if no additional flags are expected, setting this stems the problem
				_workingParams=
				return
				;;
			mount)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			unmount)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			status)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			report)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			*)
				_log 4 "_getSubcommand(): '$1' is not a subcommand"
				;;
		esac
		shift
	done
}	


#_requiredCommands=(rsync cryptsetup lsblk parted)
_isEnvSufficient() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		fi
	done
	# check for dsink dir
	if [ ! -d "${_dsinkDir}" ]; then
		_log 2 "${FUNCNAME[0]}: no ${_dsinkDir}, creating now"
 		mkdir -p "${_dsinkMount}" || _log 4 "${FUNCNAME[0]}: cannot make ${_dsinkDir}"
		touch "${_dsinkConf}" "${_logFile}" "${_dsinkCatalog}"
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}

_status() {
	echo "STATUS:${green} OK${reset}"
	exit 0
}

# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
_getBackupOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":r" flag "$@"; do
		case ${flag} in
			r)
				# future option to use when we want to do an rsync force refresh, eg
				_refresh=true
				_log 1 "${FUNCNAME[0]}: refresh mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

# SUB COMMANDS
#backup              synchronize defined local contents to mounted usb
#restore             reverse synchronize from usb to local device
#format              format a new usb portable device
#mount               open and mount usb device
#unmount             unmount and close usb device
#status              report on replication level status
#report              full report on replication level and media catalog

_backup() {
	# rsync from local source to mounted usb destination
	echo "backup from here to usb happening..."
}

_format() {
	# prompt user to insert usb
	local _usbDevicesBefore
	local _usbDevicesAfter
	_findUsbDisk
}

_findUsbDisk() {
	# attempt to locate the usb drive
	local _usbDevicesBefore=$(ls /sys/block | grep ^sd | tr '\n' ' ' | sort)
	local _usbDevicesAfter
	local _attempts=3
	local _timer=10 # time we will wait for user input
	local _sleep=4  # sleep to ensure kernel has time to recognize drive
	echo "insert usb device now"
	while [ ${_attempts} -gt 0 ]; do
		read -r -s -t ${_timer} -n 1 -p "ENTER to proceed, q to quit " _KEY
		if [[ ${_KEY} = "q" ]]; then
			echo -e "\nuser exited"; exit 1
		elif [[ ${_KEY} = "" ]]; then
			echo -e "\nchecking for new drive..."
			sleep ${_sleep}
			_usbDevicesAfter=$(ls /sys/block | grep ^sd | tr '\n' ' ' | sort)
			echo "before: '${_usbDevicesBefore}'"
			echo "after: '${_usbDevicesAfter}'"
			#if [[ -z "${_usbDevicesBefore}" ]]; then
			#	echo "none to start...and now we see ${_usbDevicesAfter}"
			#fi
			if [[ "${_usbDevicesBefore}" == "${_usbDevicesAfter}" ]]; then
				echo "NO new device detected"
			else
				_newtarget=$(comm -13 <(echo $_usbDevicesBefore) <(echo $_usbDevicesAfter))
				echo "is $_newtarget correct?"
			fi
			return 0
		else
			_attempts=$((_attempts - 1))
			echo -e "\r"
		fi
	done
}

_unmount() {
	# unmount fs, close luks device, notify device can be removed
	# must be interactive to allow sudo command
	# check for mount first
	_checkMount || _log 4 "no disnk device mounted"
	sudo umount "${_dsinkMount}" || _log 4 "${FUNCNAME[0]}: umount failed with err $?"
	sudo cryptsetup luksClose dsink || _log 4 "${FUNCNAME[0]}: luksClose failed with err $?"
	_log 1 "OK to remove usb device now"
}	

_mount() {
	# prompt use to insert dsink usb, open luks dsink, mount fs
	# check for mount first
	_checkMount && _log 4 "dsink device already mounted"
	echo "insert dsink usb now"
	sudo cryptsetup luksOpen /dev/sda1 dsink
	sudo mount /dev/mapper/dsink "${_dsinkMount}"
}

_checkMount() {
	# check for mounted dsink device
	# return 0 for true, 1 for false
	if grep -qs "${_dsinkMount}" /proc/mounts; then
		return 0
	else
		return 1
	fi
}

main() {
	# validate the environment first
	_isEnvSufficient || _log 4 "${FUNCNAME[0]}: fulfill requirements before using"
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
  # if run without arguments, run and print _status
	[ -z "${_subCommand:-}" ] && _status
	_log 0 "${FUNCNAME[0]}: _subCommand: $_subCommand"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# do it
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

