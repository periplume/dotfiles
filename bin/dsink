#!/usr/bin/env bash
# file: dsink
# source: https://github.com/periplume/dotfiles.git
# author: jason@bloom.us

# TO MY FUTURE SELF
# WHOSE MEMORY WILL STRUGGLE TO REMEMBER HOW THIS THING WORKS
# TOC MORE OR LESS:
# SCRIPT AND SHELL SETTINGS
# ENVIRONMENT SETTINGS
# DEFAULTS
# BASIC LOGGING FUNCTIONS
# HELPER FUNCTIONS
# PARAMETER PROCESSING FUNCTIONS
# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
# MAIN ENTRY AND CONTROL

# SCRIPT AND SHELL SETTINGS

# bash makin-it-hard settings
set -o errexit
set -o nounset
set -o pipefail
#set -x

# SOURCE DIR NAMES TO MANAGE
_dsinkSourceDirs=(studio lab office house library)

# REQUIRED EXTERNAL COMMANDS
_requiredCommands=(rsync cryptsetup lsblk parted wipefs)

# ENVIRONMENT SETTINGS

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=true
# silent mode for scripting (supresses stdout/stderr)
_SILENT=false
# logging facility (debug always goes here, unless)
_LOG=true

# some color
red=$(tput setaf 1)
boldred=$(tput bold; tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
yellow=$(tput setaf 3)
reset=$(tput sgr0)

# DEFAULT SETTINGS

# store dsink state and logs in $HOME/dsink
_dsinkDirName=dsink
_dsinkDir="$(dirname ~/.)/${_dsinkDirName}"
_dsinkConf="${_dsinkDir}/dsink.conf"
_logFile="${_dsinkDir}/dsink.log"
_dsinkCatalog="${_dsinkDir}/dsink.catalog"
_dsinkMount="${_dsinkDir}/media"

# LOGGING 

_log() {
	# levels
	# 0=debug eg: _log 0 "func(): value x was found and changed into x2"
	# 1=info eg: _log 1 "main(): set parameters to x y and z"
	# 2=warn eg: _log 2 "func(): doing y because the force flag was set"
	# 3=error eg: _log 3 "main(): non-fatal error, will continue trying"
	# 4=fatal eg: _log 4 "main(): fatal error, quitting"
	# ARG1 = log level (can be overridden by setting _logLevelOverride)
	# prints 1-3 no matter what, unless _LOG is false and/or _SILENT is true
	# set to 0 to force all logs into DEBUG pipe
	local _logLevelOverride=
	local _logLevel=${_logLevelOverride:-$1}
	local _logMessage="${@:2}"
	local _canLog=false
	# set timestamp for log message (unix seconds)
	local _timeStamp=$(date +%s)
	# define log levels and colors
	declare -A _i=([0]=DEBUG [1]=INFO [2]=WARN [3]=ERROR [4]=FATAL)
	declare -A _c=([0]=cyan [1]=green [2]=yellow [3]=red [4]=boldred)
	local _level=${_i[${_logLevel}]}
	local _color=${_c[${_logLevel}]}
	# check if a logfile exists
	[ -f "${_logFile}" ] && _canLog=true
	# if debug is false and message level is 0, stop
	[  ${_DEBUG} = false ] && [ ${_logLevel} = 0 ] && return
	# if _LOG is true and _logFile exists, print to log
	[ ${_LOG} = true ] && [ ${_canLog} = true ] && \
		 printf "%s\n" "${_timeStamp} ${_level}: ${_logMessage}" >> "${_logFile}"
	# if silent is true, don't print anything to the console and stop
	[ ${_SILENT} = true ] && return
	# if _SILENT is false, prettyPrint to console based on level
	if [ ! ${_SILENT} = true ]; then
		[ ${_DEBUG} = true ] && [ ${_logLevel} = 0 ]  && \
			echo "${cyan}DEBUG${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 1 ] && \
			echo "${green}INFO${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 2 ] && \
			echo "${yellow}WARN${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 3 ] && \
			echo "${red}ERROR${reset}: ${_logMessage}" && return
		[ ${_logLevel} = 4 ] && \
			echo "${boldred}FATAL${reset}: ${_logMessage}" && exit 1
	fi
}

# HELPER FUNCTIONS

_printUsage () {
  cat << EOF

usage: dsink [OPTIONS] command [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

commands:
 backup              synchronize defined local contents to mounted usb
 restore             reverse synchronize from usb to local device
 format              format a new usb portable device
 mount               open and mount usb device
 unmount             unmount and close usb device
 status              report on replication level status
 report              full report on replication level and media catalog

for command specific usage, eg:
$ dsink help backup

EOF
}

_printInfo () {
  cat << EOF

dsink maintains data replication of local data onto removable
usb devices which it encrypts (with luks).

EOF
}

# PARAMETER PROCESSING FUNCTIONS

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlv" flag ; do
		_log 0 "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
 	    s)
				_log 0 "${FUNCNAME[0]}: enabling silent mode"
 	      _SILENT=true
				;;
			d)
				_DEBUG=true
				_log 0 "${FUNCNAME[0]}: enabled debug mode"
				;;
			l)
				_LOG=true
				_log 0 "${FUNCNAME[0]}: enabled log mode"
				;;
			v)
				echo "${green}verion${reset}: beta"; exit 0
				;;
			?)
				echo "${red}ERROR${reset}: invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_log 1 "${FUNCNAME[0]}: _LOG=${_LOG}"
	_log 1 "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_log 1 "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_log 0 "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			backup)
				_log 0 "${FUNCNAME[0]}: '$1' called, checking for backup flags now"
				_subCommand=$1
				_getBackupOpts
				return
				;;
			restore)
				_log 0 "_getSubcommand(): '$1' called, check for restore flags"
				_subCommand=$1
				return
				;;
			format)
				_log 0 "_getSubcommand(): '$1' called, check for format flags"
				_subCommand=$1
				_getFormatOptions
				return
				;;
			mount)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			unmount)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			status)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			report)
				_log 0 "_getSubcommand(): '$1' called, check for mirror flags"
				_subCommand=$1
				return
				;;
			test)
				_log 0 "_getSubcommand(): '$1' called, check for format flags"
				_subCommand=$1
				_getTestOptions
				return
				;;
			*)
				_log 4 "_getSubcommand(): '$1' is not a subcommand"
				;;
		esac
		shift
	done
}	


#_requiredCommands=(rsync cryptsetup lsblk parted)
_isEnvSufficient() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_log 3 "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		fi
	done
	# check for dsink dir
	if [ ! -d "${_dsinkDir}" ]; then
		_log 2 "${FUNCNAME[0]}: no ${_dsinkDir}, creating now"
 		mkdir -p "${_dsinkMount}" || _log 4 "${FUNCNAME[0]}: cannot make ${_dsinkDir}"
		touch "${_dsinkConf}" "${_logFile}" "${_dsinkCatalog}"
	fi
	[ ${_sufficient} = true ] && return 0 || return 1
}


# SUBCOMMAND FUNCTIONS AND SUBFUNCTIONS
_getBackupOpts() {
	# check for backup flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":r" flag "$@"; do
		case ${flag} in
			r)
				# future option to use when we want to do an rsync force refresh, eg
				_refresh=true
				_log 1 "${FUNCNAME[0]}: refresh mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getFormatOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}

_getTestOptions() {
	local OPTIND=1
	set -- ${_workingParams}
	_log 0 "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":f" flag "$@"; do
		case ${flag} in
			f)
				_forceFormat=true
				_log 1 "${FUNCNAME[0]}: force mode enabled"
				;;
			?)
				_log 3 "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}
	

# SUB COMMANDS
#backup              synchronize defined local contents to mounted usb
#restore             reverse synchronize from usb to local device
#format              format a new usb portable device
#mount               open and mount usb device
#unmount             unmount and close usb device
#status              report on replication level status
#report              full report on replication level and media catalog

_backup() {
	# rsync from local source to mounted usb destination
	echo "backup from here to usb happening..."
	_rsyncDest="$_dsinkMount"
}

_format() {
	_findInsertedUsbDisk || _log 4 "no new usable usb disk found"
	echo -n "is ${yellow}$_newInsertedUsbDisk${reset} the one? [Y/n] "
	read -r -s -t 10 -n 1 _YES
	if [[ ${_YES} != "Y" ]]; then
		_log 4 "user exited"
	fi
	local _newDsinkDisk="/dev/${_newInsertedUsbDisk}"
	local _newDsinkDiskPartition="${_newDsinkDisk}1"
	findmnt ${_newDsinkDiskPartition} && _log 4 "${_newDsinkDiskPartition} is MOUNTED"
	# since we're going to reformat this device, we should wipe it before
	# either wipefs -a /dev/sdX
	# wipefs --all --backup /dev/sdX
	# or dd if=/dev/zero of=/dev/sdX bs=512 count=1 conv=notrunc
	sudo wipefs --all --backup ${_newDsinkDisk} &>/dev/null || _log 4 "ERROR"
	echo "erased the partiton table; writing new label now"
	until ls ${_newDsinkDisk} &>/dev/null; do
		sleep 1
		echo "waiting on ${_newDsinkDisk}"
	done
	sudo parted -s ${_newDsinkDisk} mklabel gpt
	sudo parted -s ${_newDsinkDisk} mkpart dsink 1 100%
	# note: waiting on devices is tricky
	# using:
	# watch -n0.1 -be ls -l /dev/sda1
	# but the easiest fix is to sleep to let the kernel repopulate the device file
	sleep 1
	sudo cryptsetup luksFormat --verify-passphrase --batch-mode ${_newDsinkDiskPartition}
	sudo cryptsetup luksOpen ${_newDsinkDiskPartition} dsink
	until ls /dev/mapper/dsink 2>/dev/null; do
		echo -n "waiting on /dev/mapper/dsink"
		sleep 1
	done
	sudo mkfs.ext4 /dev/mapper/dsink -L dsink
	# this function is not robust
}

_status() {
	echo "STATUS:${green} OK${reset}"
	exit 0
}

_test() {
	# function for use in testing things during development
	_isBlockDevice $_workingParams && echo BLOCK || echo NOT BLOCK
	set -x
	#_PTUUID=$(_getPTUUID $_workingParams) || echo "NOPE"
	_getPTUUID $_workingParams
	_getBlockType $_workingParams
	echo "TEST "
	exit 0
}

_isBlockDevice() {
	# arg1 = whole disk device to check (eg sda)
	# return 0 if true, 1 if false
	#[ -b /dev/${1:-null} ] || return 1
	[ -b /dev/${1:-null} ]
}

_getBlockType() {
	# arg1 = whole disk device (eg sda)
	# return (echo) the disk type reported by lsblk
	local _diskType=$(lsblk -oTYPE /dev/${1})
	echo $_diskType
}

_getPTUUID() {
	# ARG1 = sd device (eg sda)
	# the PTUUID is cataloged into dsink.disks at the time of format
	# return 1 if no device or not block
	# return 2 if no PTUUID found
	# echo the whole disk partition table UUID if found
	local _rawDevice=${1}
	_isBlockDevice $_rawDevice || return 1
	local _PTUUID=$(lsblk -Sn -oPTUUID /dev/${_rawDevice} 2>/dev/null)
	if [ -z "$_PTUUID" ]; then
		return 2
	else
		echo "$_PTUUID"
	fi
}
	

_findInsertedUsbDisk() {
	# to be run when new usb device needs to be found
	# interactive prompt with user
	# sequence requires prompt, user to manually insert device, discovery
	# return 1 when no NEW devices found
	# return 0 when new device is discovered (and confirmed)
	# makes global the VAR _newInsertedUsbDisk
	local _usbDisksBefore=($(ls /sys/block | grep ^sd))
	local _usbDisksAfter
	declare -g _newInsertedUsbDisk
	local _attempts=3
	local _timer=20
	echo "insert new usb disk now, then press ENTER to proceed"
	while [ ${_attempts} -gt 0 ]; do
		echo "press ENTER to ${green}proceed${reset}, q to ${red}quit${reset}"
		read -r -s -t ${_timer} -n 1 _KEY
		if [[ ${_KEY} = "q" ]]; then
			echo -e "\nuser exited"; exit 1
		elif [[ ${_KEY} = "" ]]; then
			echo -e "\nsearching for new drive now..."
			# the sleep here gives the kernel time to add the device
			sleep 9
			# NOTE: SEAGATE SPINNING DISK TAKES A LONG TIME...10 seconds is needed!
			_usbDisksAfter=($(ls /sys/block | grep ^sd))
			_newDeviceCount=$((${#_usbDisksAfter[@]}-${#_usbDisksBefore[@]}))
			if [[ $_newDeviceCount -eq 1 ]]; then
				break
			elif [[ $_newDeviceCount -eq 0 ]]; then
				return 1
			else
				_log 4 "$_newDeviceCount new sd devices found, unexpected"
			fi
		fi
	done
	# find the new device by comparing before and after lists
	for i in "${_usbDisksAfter[@]}"; do
		skip=
		for x in "${_usbDisksBefore[@]}"; do
			[[ $i == $x ]] && { skip=1; break; }
		done
			[[ -n $skip ]] || _newInsertedUsbDisk=$i
	done
	_deviceFile="/dev/${_newInsertedUsbDisk}"
	_devicePartitionList=$(ls ${_deviceFile}? | tr '\n' ' ')
	_isBlockDevice ${_deviceFile} && echo ERRRRRRRRRRRRRROR 
	ls ${_deviceFile}?
	#
	# NEED TO make more robust...ie if there are no partitions
	echo -e "\n==============PHYSICAL:========================================"
	lsblk -S -oNAME,SIZE,VENDOR,PTTYPE,SERIAL,PTUUID ${_deviceFile}
	echo -e "\n==============LOGICAL:========================================="
	if [ -n "${_devicePartitionList}" ]; then
		lsblk -oNAME,PARTLABEL,SIZE,FSTYPE,PARTUUID ${_devicePartitionList} 
	else
		echo "no partitions found on device"
	fi
	_mounts=0
	echo -e "\n==============STATE:==========================================="
	for i in ${_devicePartitionList}; do
		if findmnt $i >/dev/null; then
			_target=$(findmnt -n -o TARGET $i)
			echo "$i is ${red}MOUNTED${reset} as ${_target}"
			if ls -A1q "${_target}" | grep -q .; then
				! echo "$i is ${red}NOT EMPTY${reset}"
				echo "check the data...will not proceed"
				_mounts=1
			else
				echo "$i is ${green}EMPTY${reset}"
				echo "press ENTER to ${yellow}unmount${reset}, q to ${red}abort${reset}"
				read -r -s -t ${_timer} -n 1 _UM
				if [[ ${_UM} = "q" ]]; then
					_log 4 "user exited...unmount $_target and retry"
				elif [[ ${_UM} = "" ]]; then
					sudo umount "${_target}" || _log 4 "could not unmount $_target"
					_mounts=0
				else
					_mounts=1
				fi
			fi
		fi
	done
	if [[ $_mounts -eq 0 ]]; then
		return 0
	else
		return 1
	fi
}

_unmount() {
	# unmount fs, close luks device, notify device can be removed
	# must be interactive to allow sudo command
	# check for mount first
	_checkMount || _log 4 "no disnk device mounted"
	sudo umount "${_dsinkMount}" || _log 4 "${FUNCNAME[0]}: umount failed with err $?"
	sudo cryptsetup luksClose dsink || _log 4 "${FUNCNAME[0]}: luksClose failed with err $?"
	_log 1 "OK to remove usb device now"
}	

_mount() {
	# prompt use to insert dsink usb, open luks dsink, mount fs
	# check for mount first
	_detectedDsinkDevice=
	_checkMount && _log 4 "dsink device already mounted"
	echo "insert dsink usb now"
	if [ -e /dev/disk/by-partlabel/dsink ]; then
		echo "dsink partition detected"
		_detectedDsinkDevice=$(readlink -f /dev/disk/by-partlabel/dsink)
	else
		echo "no dsink partition available"
	fi
	if [ -n "${_detectedDsinkDevice}" ]; then
		if [ ! -e /dev/mapper/dsink ]; then
			sudo cryptsetup luksOpen ${_detectedDsinkDevice} dsink
		fi
		sudo mount /dev/mapper/dsink "${_dsinkMount}"
		sudo chown jason:jason "${_dsinkMount}"
	else
		echo "insert a dsink device and try again"
	fi
}

_checkMapperFile() {
	if [ -e /dev/mapper/dsink ]; then
		return 0
	else
		return 1
	fi
}

_findUnmountedDsink() {
	# search for a dsink device
	echo DO
}

_checkMount() {
	# check for mounted dsink device
	# return 0 for true, 1 for false
	if grep -qs "${_dsinkMount}" /proc/mounts; then
		return 0
	else
		return 1
	fi
}

main() {
	# validate the environment first
	_isEnvSufficient || _log 4 "${FUNCNAME[0]}: fulfill requirements before using"
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_log 0 "${FUNCNAME[0]}: parameters read: ${@}"
	_log 0 "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
  # if run without arguments, run and print _status
	[ -z "${_subCommand:-}" ] && _status
	_log 0 "${FUNCNAME[0]}: _subCommand: $_subCommand"
	_log 0 "${FUNCNAME[0]}: remaining args: $_workingParams"
	# do it
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}"
}
main "${@}"

